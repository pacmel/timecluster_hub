# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/xai.ipynb.

# %% auto 0
__all__ = ['get_dataset', 'umap_parameters', 'get_prjs', 'plot_projections', 'plot_projections_clusters',
           'calculate_cluster_stats', 'anomaly_score', 'detector', 'plot_anomaly_scores_distribution',
           'plot_clusters_with_anomalies', 'update_plot', 'plot_clusters_with_anomalies_interactive_plot',
           'InteractiveAnomalyPlot', 'plot_save', 'get_anomalies', 'get_anomaly_styles', 'plot_initial_config']

# %% ../nbs/xai.ipynb 1
#Weight & Biases
import wandb

#Yaml
from yaml import load, FullLoader

#Embeddings
from .all import *
from tsai.data.preparation import prepare_forecasting_data
from tsai.data.validation import get_forecasting_splits
from fastcore.all import *

#Dimensionality reduction
from tsai.imports import *

#Clustering
import hdbscan
import time
from .dr import get_PCA_prjs, get_UMAP_prjs, get_TSNE_prjs

import seaborn as sns
import matplotlib.pyplot as plt
import pandas as pd
import ipywidgets as widgets
from IPython.display import display
from functools import partial

from IPython.display import display, clear_output, HTML as IPHTML
from ipywidgets import Button, Output, VBox, HBox, HTML, Layout, FloatSlider

import plotly.graph_objs as go
import plotly.offline as py
import plotly.io as pio
#! pip install kaleido
import kaleido


# %% ../nbs/xai.ipynb 4
def get_dataset(config, run_dr, config_dr, api, print_flag = False):
    # Botch to use artifacts offline
    artifacts_gettr = run_dr.use_artifact if config_dr.use_wandb else api.artifact
    enc_artifact = artifacts_gettr(config.enc_artifact, type='learner')
    if print_flag: print (enc_artifact.name)
    ## TODO: This only works when you run it two timeS! WTF?
    try:
        enc_learner = enc_artifact.to_obj()
    except:
        enc_learner = enc_artifact.to_obj()
    #enc_artifact.metadata
    ## Restore artifact
    enc_logger = enc_artifact.logged_by()
    enc_artifact_train = artifacts_gettr(enc_logger.config['train_artifact'], type='dataset')
    if enc_logger.config['valid_artifact'] is not None:
        enc_artifact_valid = artifacts_gettr(enc_logger.config['valid_artifact'], type='dataset')
        if print_flag: print("enc_artifact_valid:", enc_artifact_valid.name)
    if print_flag: print("enc_artifact_train: ", enc_artifact_train.name)
    if config_dr.dr_artifact is not None:
        dr_artifact = artifacts_gettr(config_dr.dr_artifact)
    else:
        dr_artifact = enc_artifact_train
    if print_flag: print("DR artifact train: ", dr_artifact.name)
    df = dr_artifact.to_df()
    if print_flag: display(df.head())
    return df, dr_artifact, enc_artifact, enc_learner

# %% ../nbs/xai.ipynb 5
def umap_parameters(config_dr, config):
    umap_params_cpu = {
        'n_neighbors' : config_dr.n_neighbors,
        'min_dist' : config_dr.min_dist,
        'random_state': np.uint64(822569775), 
        'metric': config_dr.metric,
        #'a': 1.5769434601962196,
        #'b': 0.8950608779914887,
        #'metric_kwds': {'p': 2}, #No debería ser necesario, just in case
        #'output_metric': 'euclidean',
        'verbose': 4,
        #'n_epochs': 200
    }
    umap_params_gpu = {
        'n_neighbors' : config_dr.n_neighbors,
        'min_dist' : config_dr.min_dist,
        'random_state': np.uint64(1234), 
        'metric': config_dr.metric,
        'a': 1.5769434601962196,
        'b': 0.8950608779914887,
        'target_metric': 'euclidean',
        'target_n_neighbors': config_dr.n_neighbors,
        'verbose': 4, #6, #CUML_LEVEL_TRACE
        'n_epochs': 200*3*2,
        'init': 'random',
        'hash_input': True
    }
    if config.cpu_flag: 
        umap_params = umap_params_cpu
    else:
        umap_params = umap_params_gpu
    return umap_params

# %% ../nbs/xai.ipynb 6
def get_prjs(embs_no_nan, config_dr, config, print_flag = False):
    umap_params = umap_parameters(config_dr, config)
    prjs_pca = get_PCA_prjs(
        X    = embs_no_nan, 
        cpu  = False,  
        print_flag = print_flag, 
        **umap_params
    )
    if print_flag: 
        print(prjs_pca.shape)
    prjs_umap = get_UMAP_prjs(
        input_data = prjs_pca, 
        cpu =  config.cpu_flag, #config_dr.cpu, 
        print_flag = print_flag,         
        **umap_params
    )
    if print_flag: prjs_umap.shape
    return prjs_umap

# %% ../nbs/xai.ipynb 8
def plot_projections(prjs, umap_params, fig_size = (25,25)):
    "Plot 2D projections thorugh a connected scatter plot"
    df_prjs = pd.DataFrame(prjs, columns = ['x1', 'x2'])
    fig = plt.figure(figsize=(fig_size[0],fig_size[1]))
    ax = fig.add_subplot(111)
    ax.scatter(df_prjs['x1'], df_prjs['x2'], marker='o', facecolors='none', edgecolors='b', alpha=0.1)
    ax.plot(df_prjs['x1'], df_prjs['x2'], alpha=0.5, picker=1)
    plt.title('DR params -  n_neighbors:{:d} min_dist:{:f}'.format(
        umap_params['n_neighbors'],umap_params['min_dist']))
    return ax

# %% ../nbs/xai.ipynb 9
def plot_projections_clusters(prjs, clusters_labels, umap_params, fig_size = (25,25)):
    "Plot 2D projections thorugh a connected scatter plot"
    df_prjs = pd.DataFrame(prjs, columns = ['x1', 'x2'])
    df_prjs['cluster'] = clusters_labels
    
    fig = plt.figure(figsize=(fig_size[0],fig_size[1]))
    ax = fig.add_subplot(111)
    
    # Create a scatter plot for each cluster with different colors
    unique_labels = df_prjs['cluster'].unique()
    print(unique_labels)
    for label in unique_labels:
        cluster_data = df_prjs[df_prjs['cluster'] == label]
        ax.scatter(cluster_data['x1'], cluster_data['x2'], label=f'Cluster {label}')
        #ax.scatter(df_prjs['x1'], df_prjs['x2'], marker='o', facecolors='none', edgecolors='b', alpha=0.1)
    
    #ax.plot(df_prjs['x1'], df_prjs['x2'], alpha=0.5, picker=1)
    plt.title('DR params -  n_neighbors:{:d} min_dist:{:f}'.format(
        umap_params['n_neighbors'],umap_params['min_dist']))
    return ax

# %% ../nbs/xai.ipynb 10
def calculate_cluster_stats(data, labels):
    """Computes the media and the standard deviation for every cluster."""
    cluster_stats = {}
    for label in np.unique(labels):
        #members = data[labels == label]
        members = data
        mean = np.mean(members, axis = 0)
        std = np.std(members, axis = 0)
        cluster_stats[label] = (mean, std)
    return cluster_stats

# %% ../nbs/xai.ipynb 11
def anomaly_score(point, cluster_stats, label):
    """Computes an anomaly score for each point."""
    mean, std = cluster_stats[label]
    return np.linalg.norm((point - mean) / std)

# %% ../nbs/xai.ipynb 12
def detector(data, labels):
    """Anomaly detection function."""
    cluster_stats = calculate_cluster_stats(data, labels)
    scores = []
    for point, label in zip(data, labels):
        score = anomaly_score(point, cluster_stats, label)
        scores.append(score)
    return np.array(scores)

# %% ../nbs/xai.ipynb 14
def plot_anomaly_scores_distribution(anomaly_scores):
    "Plot the distribution of anomaly scores to check for normality"
    plt.figure(figsize=(10, 6))
    sns.histplot(anomaly_scores, kde=True, bins=30)
    plt.title("Distribución de Anomaly Scores")
    plt.xlabel("Anomaly Score")
    plt.ylabel("Frecuencia")
    plt.show()

# %% ../nbs/xai.ipynb 15
def plot_clusters_with_anomalies(prjs, clusters_labels, anomaly_scores, threshold, fig_size=(25, 25)):
    "Plot 2D projections of clusters and superimpose anomalies"
    df_prjs = pd.DataFrame(prjs, columns=['x1', 'x2'])
    df_prjs['cluster'] = clusters_labels
    df_prjs['anomaly'] = anomaly_scores > threshold

    fig = plt.figure(figsize=(fig_size[0], fig_size[1]))
    ax = fig.add_subplot(111)

    # Plot each cluster with different colors
    unique_labels = df_prjs['cluster'].unique()
    for label in unique_labels:
        cluster_data = df_prjs[df_prjs['cluster'] == label]
        ax.scatter(cluster_data['x1'], cluster_data['x2'], label=f'Cluster {label}', alpha=0.7)

    # Superimpose anomalies
    anomalies = df_prjs[df_prjs['anomaly']]
    ax.scatter(anomalies['x1'], anomalies['x2'], color='red', label='Anomalies', edgecolor='k', s=50)

    plt.title('Clusters and anomalies')
    plt.legend()
    plt.show()

def update_plot(threshold, prjs_umap, clusters_labels, anomaly_scores, fig_size):
    plot_clusters_with_anomalies(prjs_umap, clusters_labels, anomaly_scores, threshold, fig_size)

def plot_clusters_with_anomalies_interactive_plot(threshold, prjs_umap, clusters_labels, anomaly_scores, fig_size):
    threshold_slider = widgets.FloatSlider(value=threshold, min=0.001, max=3, step=0.001, description='Threshold')
    interactive_plot =  widgets.interactive(update_plot, threshold = threshold_slider, 
                              prjs_umap = widgets.fixed(prjs_umap), 
                              clusters_labels = widgets.fixed(clusters_labels),
                              anomaly_scores = widgets.fixed(anomaly_scores),
                              fig_size = widgets.fixed((25,25)))
    display(interactive_plot)
    

# %% ../nbs/xai.ipynb 17
import plotly.express as px

# %% ../nbs/xai.ipynb 18
class InteractiveAnomalyPlot():
    def __init__(
        self, selected_indices = [], 
        threshold = 0.15, 
        anomaly_flag = False,
        path = "../imgs", w = 0
    ):
        self.selected_indices = selected_indices
        self.threshold = threshold
        self.anomaly_flag = anomaly_flag
        self.w = w,
        self.name = f"w={self.w}"
        self.path = f"{path}{self.name}.png"
    

    def plot_projections_clusters_interactive(
        self, prjs, cluster_labels, umap_params, anomaly_scores=[], fig_size=(7,7), print_flag = False
    ):
        threshold_ = self.threshold
        selected_indices_tmp = self.selected_indices
        py.init_notebook_mode()

        prjs_df, cluster_colors = plot_initial_config(prjs, cluster_labels, anomaly_scores)
        legend_items = [widgets.HTML(f'<b>Cluster {cluster}:</b> <span style="color:{color};">■</span>')
                        for cluster, color in cluster_colors.items()]
        legend = widgets.VBox(legend_items)

        marker_colors = prjs_df['cluster'].map(cluster_colors)
    
        symbols, line_colors = get_anomaly_styles(prjs_df, threshold_, anomaly_scores, self.anomaly_flag, print_flag)
    
        fig = go.FigureWidget(
            [
                go.Scatter(
                    x=prjs_df['x1'], y=prjs_df['x2'], 
                    mode="markers", 
                    marker= {
                        'color': marker_colors,
                        'line': { 'color': line_colors, 'width': 1 },
                        'symbol': symbols
                    },
                    text = prjs_df.index
                )
            ]
        )

        line_trace = go.Scatter(
            x=prjs_df['x1'],  # Reemplaza 'x1' y 'x2' con los nombres de tus columnas de datos
            y=prjs_df['x2'],  # Reemplaza 'x1' y 'x2' con los nombres de tus columnas de datos
            mode="lines",  # Establece el modo en "lines"
            line=dict(color='rgba(128, 128, 128, 0.5)', width=1),
            showlegend=False  # Puedes configurar si deseas mostrar esta línea en la leyenda
        )
    
        fig.add_trace(line_trace)

        sca = fig.data[0]
        
        fig.update_layout(
            dragmode='lasso',
            width=700, 
            height=500,
            title={
                'text': '<span style="font-weight:bold">DR params - n_neighbors:{:d} min_dist:{:f}</span>'.format(
                         umap_params['n_neighbors'], umap_params['min_dist']),
                'y':0.98,
                'x':0.5,
                'xanchor': 'center',
                'yanchor': 'top'
            },
            plot_bgcolor='white',
            paper_bgcolor='#f0f0f0',
            xaxis=dict(gridcolor='lightgray', zerolinecolor='black', title = 'x'), 
            yaxis=dict(gridcolor='lightgray', zerolinecolor='black', title = 'y'),
            margin=dict(l=10, r=20, t=30, b=10)
        
        
        )
    
        output_tmp = Output()
        output_button = Output()
        output_anomaly = Output()
    
    
        def select_action(trace, points, selector):
            global selected_indices_tmp
            selected_indices_tmp = points.point_inds
            with output_tmp:
                output_tmp.clear_output(wait=True)
                print("Selected indices tmp:", selected_indices_tmp)
        
        def button_action(b):
            #global selected_indices
            global selected_indices_tmp
            self.selected_indices = selected_indices_tmp 
            with output_button: 
                output_button.clear_output(wait = True)
                print("Selected indices:", self.selected_indices)

    
        def update_anomalies(anomaly_flag):
            #nonlocal threshold_
            #nonlocal anomaly_scores
            #nonlocal fig
            #nonlocal print_flag
            
            if print_flag: print("About to update anomalies")
            symbols, line_colors = get_anomaly_styles(prjs_df,threshold_,anomaly_flag)
    
            with fig.batch_update():
                fig.data[0].marker.symbol = symbols
                fig.data[0].marker.line.color = line_colors
    
            if print_flag: print("Threshold: ", threshold_)
            if print_flag: print("Scores: ", anomaly_scores)
        
              
        def anomaly_action(b):
            #nonlocal anomaly_flag
            self.anomaly_flag = not self.anomaly_flag
            with output_anomaly:  # Cambia output_flag a output_anomaly
                output_anomaly.clear_output(wait=True)
                if print_flag:
                    print("Show anomalies:", self.anomaly_flag)
                update_anomalies(self.anomaly_flag)
                    
                
            
        
        sca.on_selection(select_action)
        layout = widgets.Layout(width='auto', height='40px')
        button = Button(
            description="Update selected_indices",
            style = {'button_color': 'lightblue'},
            display = 'flex',
            flex_row = 'column',
            align_items = 'stretch',
            layout = layout
        )
        anomaly_button = Button(
            description = "Show anomalies",
            style = {'button_color': 'lightgray'},
            display = 'flex',
            flex_row = 'column',
            align_items = 'stretch',
            layout = layout
        )
        
        button.on_click(button_action)
        anomaly_button.on_click(anomaly_action)
    
        ##### Reactivity buttons
        pause_button = Button(
            description = "Pause interactiveness",
            style = {'button_color': 'pink'},
            display = 'flex',
            flex_row = 'column',
            align_items = 'stretch',
            layout = layout
        )
        resume_button = Button(
            description = "Resume interactiveness",
            style = {'button_color': 'lightgreen'},
            display = 'flex',
            flex_row = 'column',
            align_items = 'stretch',
            layout = layout
        )

    
        threshold_slider = FloatSlider(
            value=threshold_,
            min=0.0,
            max=float(np.ceil(self.threshold+5)),
            step=0.01,
            description='Anomaly threshold:',
            continuous_update=False
        )
    
        interaction_enabled = True
        def pause_interaction(b):
            global interaction_enabled
            interaction_enabled = False
            fig.update_layout(dragmode='pan')
    
        def resume_interaction(b):
            global interaction_enabled
            interaction_enabled = True
            fig.update_layout(dragmode='lasso')

    
        def update_threshold(change):
            #nonlocal threshold_
            #nonlocal anomaly_flag
            threshold_ = change.new
            update_anomalies(self.anomaly_flag)
        

        pause_button.on_click(pause_interaction)
        resume_button.on_click(resume_interaction)
    
        threshold_slider.observe(update_threshold, 'value')
    
        #####
        space = HTML("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;") 
    
        vbox = VBox((output_tmp, output_button, output_anomaly, fig))
        hbox = HBox((space, button, space, pause_button, space, resume_button, anomaly_button))
    
        # Centrar las dos cajas horizontalmente en el VBox

        box_layout = widgets.Layout(display='flex',
                    flex_flow='column',
                    align_items='center',
                    width='100%')

        if self.anomaly_flag:
            box = VBox((hbox,threshold_slider,vbox), layout = box_layout)
        else: 
            box = VBox((hbox,vbox), layout = box_layout)
        box.add_class("layout")
        plot_save(fig, self.w)
    
        display(box)


# %% ../nbs/xai.ipynb 19
def plot_save(fig, w):
    image_bytes = pio.to_image(fig, format='png')
    with open(f"../imgs/w={w}.png", 'wb') as f:
        f.write(image_bytes)
    

# %% ../nbs/xai.ipynb 20
def get_anomalies(df, threshold, flag):
    df['anomaly'] = [ (score > threshold) and flag for score in df['anomaly_score']]
    
def get_anomaly_styles(df, threshold, anomaly_scores, flag = False, print_flag = False):
        if print_flag: print("Threshold: ", threshold)
        if print_flag: print("Flag", flag)
        if print_flag: print("df ~", df.shape)
        df['anomaly'] = [ (score > threshold) and flag for score in df['anomaly_score'] ]
        print(df)
        get_anomalies(df, threshold, flag)
        anomalies = df[df['anomaly']]
        if flag:
            df['anomaly'] = [ 
                (score > threshold) and flag 
                for score in anomaly_scores 
            ]
            symbols = [
                'x' if is_anomaly else 'circle' 
                for is_anomaly in df['anomaly']
            ]
            line_colors = [
                'black'
                if (is_anomaly and flag) else 'rgba(0,0,0,0)'
                for is_anomaly in df['anomaly']
            ]
        else:
            symbols = ['circle' for _ in df['x1']]
            line_colors = ['rgba(0,0,0,0)' for _ in df['x1']]
        if print_flag: print(anomalies)
        return symbols, line_colors
### Example of use
#prjs_df = pd.DataFrame(prjs_umap, columns = ['x1', 'x2'])
#prjs_df['anomaly_score'] = anomaly_scores
#s, l = get_anomaly_styles(prjs_df, 1, True)

# %% ../nbs/xai.ipynb 21
def plot_initial_config(prjs, cluster_labels, anomaly_scores):
    prjs_df = pd.DataFrame(prjs, columns = ['x1', 'x2'])
    prjs_df['cluster'] = cluster_labels
    prjs_df['anomaly_score'] = anomaly_scores
    
    cluster_colors_df = pd.DataFrame({'cluster': cluster_labels}).drop_duplicates()
    cluster_colors_df['color'] = px.colors.qualitative.Set1[:len(cluster_colors_df)]
    cluster_colors = dict(zip(cluster_colors_df['cluster'], cluster_colors_df['color']))
    return prjs_df, cluster_colors
