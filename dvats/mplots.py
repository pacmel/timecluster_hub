# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/mplots.ipynb.

# %% auto 0
__all__ = ['mplot_path', 'eamonn_drive_mplots', 'euclidean_distance', 'z_normalize', 'z_normalized_euclidean_distance',
           'show_sequence', 'plot_with_dots', 'show_subsequence', 'GD_Mat', 'MatlabMatrix', 'plot_dataFrame',
           'plot_dataFrame_compareSubsequences', 'df_plot_colored_variables', 'plot_df_with_intervals_and_colors',
           'make_symmetric_', 'check_symmetric', 'moving_mean', 'sum_of_squared_differences', 'get_precomputes',
           'convert_non_finite_to_zero', 'distance_matrix', 'DistanceProfile', 'DistanceMatrix', 'plot_motif',
           'plot_motif_separated', 'MatrixProfile', 'matrix_profile', 'MatrixProfiles', 'MatrixProfilePlot',
           'MatrixProfilePlotCached']

# %% ../nbs/mplots.ipynb 4
## -- Deepvats
import dvats.load as load
import dvats.memory as mem
import dvats.utils as ut

## -- Matrix profile
import pyscamp as scamp
import stumpy as stump 
## -- Utilities
import os
import numpy as np
import pandas as pd
import datetime as dt
import math
import warnings

## -- Classes & types
from dataclasses import dataclass, field
from typing import List, Optional, Tuple, Callable
## -- Plotting
import matplotlib
import matplotlib.pyplot as plt
import matplotlib.dates as dates

from matplotlib.gridspec import GridSpec
from matplotlib.patches import Rectangle

from mpl_toolkits.axes_grid1 import ImageGrid

## -- Interactive Plots
import ipywidgets as widgets
from IPython.display import display, clear_output


from copy import deepcopy
plt.style.use('https://raw.githubusercontent.com/TDAmeritrade/stumpy/main/docs/stumpy.mplstyle')

from concurrent.futures import ThreadPoolExecutor



# %% ../nbs/mplots.ipynb 5
#-- "Importing" MPlots MATLAB code
from oct2py import octave
mplot_path = os.path.expanduser('~/work/nbs/mplot')
octave.addpath(mplot_path);
octave.chdir(mplot_path);
#%load_ext oct2py.ipython
octave.register_graphics_toolkit('fltk')
octave.graphics_toolkit('fltk')
octave.set(0, 'defaultfigurevisible', 'on');

# %% ../nbs/mplots.ipynb 9
def euclidean_distance (
    vector_a    : List [ float ],
    vector_b    : List [ float ],
    print_flag  : bool = False,
    time_flag   : bool = False
) -> Tuple[float, Optional[ ut.Time ]]:
    """
    Calculates the Euclidean distance between two vectors.

    Args:
        vector_a: First vector as a list of floats.
        vector_b: Second vector as a list of floats.
        print_flag: If True, prints the vectors.
        time_flag: If True, measures and displays the time taken by the function.

    Returns:
        A tuple containing the distance and an object of Time if time_flag is True, or None otherwise.
    """
    t = None 
    #if print_flag: print("--> Ensuring the vectors are numpy arrays")
    vector_a = np.array(vector_a)
    vector_b = np.array(vector_b)
    if print_flag: 
        print("va", vector_a)
        print("vb", vector_b)
    if time_flag:
        t = ut.Time(function = ut.funcname())
        t.start(print_flag = print_flag)
    dist = np.linalg.norm(vector_a - vector_b)
    if time_flag: 
        t.end(print_flag = print_flag)
        if print_flag: t.show()
    return dist, t

# %% ../nbs/mplots.ipynb 12
def z_normalize(
    sequence    : List [ float ],
    print_flag  : bool = False,
    time_flag   : bool = False
) -> Tuple[ List[ float ], Optional[ ut.Time ] ]:
    t = None
    if time_flag:
        t = ut.Time(function=ut.funcname())
        t.start(print_flag)
    
    mean    = np.mean(sequence)
    std     = np.std(sequence)
    res     = (sequence - mean) / std
    
    if time_flag: 
        t.end(print_flag)
        if print_flag: t.show()
    return res, t

# %% ../nbs/mplots.ipynb 14
def z_normalized_euclidean_distance(
    vector_a    : List [ float ],
    vector_b    : List [ float ],
    print_flag  : bool = False,
    time_flag   : bool = False,
    inside_times: bool = False
) -> Tuple[ List [ float ], Optional[ ut.Time ], Optional [ List [ ut.Time ] ] ]:
    t = None
    ts = [ None, None, None ]
    if print_flag: 
        print("va", vector_a)
        print("vb", vector_b)

    if time_flag:
        t = ut.Time( function = ut.funcname() )
        t.start(print_flag)
    
    #-- Normalize
    vector_a, ts[0] = z_normalize(vector_a, time_flag = inside_times)
    vector_b, ts[1] = z_normalize(vector_b, time_flag = inside_times)   

    #-- Compute distance
    res, ts[2] = euclidean_distance(vector_a, vector_b, time_flag = inside_times)
    
    if time_flag:
        t.end(print_flag)
        if print_flag: t.show()
    if print_flag: 
        print("zn-va", vector_a)
        print("zn-vb", vector_b)
        print("dist", res)
    return res, t, ts

# %% ../nbs/mplots.ipynb 19
def show_sequence(
    data         : List[ List [ float ] ] = None, 
    hide_rows    : bool = False, 
    hide_columns : bool = True
):
    """
    Show the sequence in a nice format similar to stumpy tutorials
    """
    df          = pd.DataFrame(data)
    styled_df   = df.style
    if hide_rows: 
        styled_df = styled_df.hide(axis='index')
    if hide_columns: 
        styled_df = styled_df.hide(axis='columns')
    styled_df = styled_df.set_table_styles([
        {'selector': '',
         'props': [('border', '2px solid black'),
                   ('text-align', 'center'),
                   ('font-family', 'Arial'),
                   ('border-collapse', 'collapse')]},
        {'selector': 'td',
         'props': [('border', '1px solid black'),
                   ('padding', '5px')]}
    ])
    display(styled_df)

# %% ../nbs/mplots.ipynb 20
def plot_with_dots(
    time_series             : List [ float ]    = None,
    xlabel                  : str               = 'Index (time)',
    ylabel                  : str               = 'Value',
    title                   : str               = 'Time series',
    sequence_flag           : bool              = True,
    show_sequence_before    : bool              = True, 
    hide_rows               : bool              = True,
    hide_columns            : bool              = False,
    show_title              : bool              = True   
  ) -> None:
    if sequence_flag and show_sequence_before: 
        show_sequence([time_series], hide_rows, hide_columns)
    n = len(time_series)
    x_coords = range(n)
    plt.plot(x_coords, time_series)
    plt.scatter(x_coords, time_series, color='red')
    if show_title: plt.title(title)
    plt.xlabel(xlabel)
    plt.ylabel(ylabel)
    plt.show()
    if sequence_flag and not show_sequence_before: show_sequence([time_series], hide_rows, hide_columns)
    return None



# %% ../nbs/mplots.ipynb 23
def show_subsequence(
        data         : List [ float ], 
        i            : int  = 0, 
        m            : int  = 1, 
        hide_rows    : bool = False, 
        hide_columns : bool = True, 
    ):
        """ Show the subsequence in a nice format similar to stumpy tutorials"""
        show_sequence(
                data            = [data[i:m]],
                hide_rows       = hide_rows, 
                hide_columns    = hide_columns, 
        )

# %% ../nbs/mplots.ipynb 28
class GD_Mat:
    def __init__(self, id,  name, data_path = '~/data'):
        self.id                 = id #GD id
        self.data_path          = os.path.expanduser(data_path) # Local data path
        self.zip_path           = os.path.join(self.data_path, name + '.zip')
        self.mat_path           = os.path.join(self.data_path, name + '.mat')
        self.mats_files         = None
        self.mats               = None #Downloaded matlab matrices
        self.mats_df            = None
        self.num_mats           = 0
        self.num_mats_extracted = 0
        
    def download_file_from_google_drive(self):
        return load.download_file_from_google_drive(self.id, self.zip_path)
        
    def get_mat_files(self):
        self.mats_files = [f for f in load.zip_contents(self.zip_path) if not f.startswith('__MACOSX/')]
        self.num_mats = len(self.mats_files)
        self.mats = self.mats_df = [None]*self.num_mats
    
    def unzip_mat(self, all_one, case = '', print_flag = False): 
        str = load.unzip_mat(all_one, self.zip_path, self.data_path, case, print_flag)
        self.get_mat_files()
        return str
        
    def mat2csv(self, case_id, print_flag = False):
        if print_flag: print("--> mat2csv", case_id)
        case = self.mats_files[case_id]
        case_path = os.path.join(self.data_path, case)
        print("Mat2csv case", case_path)
        self.mats_df[case_id] = load.mat2csv(case_path, self.data_path, print_flag)
        if print_flag: print("mat2csv", case_id, "-->")
        
    def __str__(self): 
        str = f"FileID: {self.id}\nData path: {self.data_path}\n"
        str += f"zip path: {self.zip_path}\nmat_files: {self.mats_files}"
        str +=f"\nnum_mats: {self.num_mats}"
        return str

# %% ../nbs/mplots.ipynb 29
@dataclass
class MatlabMatrix: 
    #File name
    filename : str = ""
    #Matrix name
    matname : str = ""
    #1-D numpy array with the time serie data
    data : List [ float ] = None
    #Length used for smoothing the time serie (if smoothed)
    smoothing_window_len : int = None
    #Wether if it has been smoothed yet or not 
    smoothed : bool = False
    path : str = None
    
    def load(
        self, 
        #Col in the matrix containing the time serie
        numcol : int, 
        #Wether to print messages for debugging or not
        print_flag : bool = False,
        force_smooth : bool = False,
        path = "."
    ) -> List [ float ] : 
        """ Reads the file and load the column numcol of the matrix as time series data. """
        
        if self.path is None:
            path = path

        dir = self.path + '/' + self.filename  + ".mat"
        
        dict = octave.load(dir)
        data = dict[self.matname]
        
        if print_flag: print(data.dtype)
        
        self.data = np.array(data[:,numcol])
        
        return self.data

    def smooth(
        self, 
        window_len=11, 
        print_flag = False,
        force_smooth = False
    ) -> List [ float ]:
        """ Applies moving average for smoothing the time serie data. """
        # window_len: smoothing window size needs, which must be odd number,
        
        if ( ( not self.smoothed ) or force_smooth ) :
            self.smoothed = True
        
            # Step 1: Apply the moving average to the main part of the data using convolution
        
            self.smoothing_window_len = window_len
        
            if self.smoothing_window_len % 2 == 0:
                warnings.warn("Window len must be odd! Adding 1 to your length.")
                self.smoothing_window_len += 1
            
            if print_flag: print("---> About to get out0")
            
            out0 = np.convolve(
                self.data, 
                np.ones(self.smoothing_window_len, dtype=int),
                'valid'
            ) / self.smoothing_window_len
        
            # Step 2: Handle the beginning of the array (start)
            # Use cumulative sum and then average it by the increasing window size
        
            if print_flag : 
                print("out0 ~", out0.shape)
                print("---> About to get start")
        
            r = np.arange(1, self.smoothing_window_len-1, 2)
        
            if print_flag: print("r", r)
        
            start = np.cumsum(self.data[:self.smoothing_window_len-1])[::2] / r
        
            if print_flag:
                print("start", start)
                print("---> About to get stop")
        
            # Step 3: Handle the end of the array (stop)
            # Reverse the array, use cumulative sum, and then average it by the increasing window size
        
            stop = (np.cumsum(self.data[:-self.smoothing_window_len:-1])[::2] / r)[::-1]
    
            if print_flag: 
                print("stop", stop)
        
            # Step 4: Combine the start, middle, and end parts together
            self.data = np.concatenate((start, out0, stop))
            return self.data

# %% ../nbs/mplots.ipynb 35
def plot_dataFrame(title, df, vars = [], interval = 10000):
    if len(vars) > 0:
        num_vars = len(df.columns)
    
        for var_num in vars:
            if var_num >= len(df.columns):
                raise ValueError("var_num "+var[var_num] + "is out of the range of DataFrame columns: " + num_vars)

        num_vars = len(vars)
        
        ### Start the plot 

        #fig = plt.figure(figsize=(10, num_intervals * 3))  # Ajusta el tamaño del plot según el número de intervalos
        
        num_intervals = df.shape[0] // interval + 1
        fig = plt.figure(figsize=(10, num_vars * num_intervals * 3))  ## Size
        gs = GridSpec(num_intervals*num_vars, 1) # 1 column, len(vars) rows
        var_pos = 0
        for var_num  in vars:
            var_name = df.columns[var_num]
            data = df[var_name]
            for i in range(num_intervals):    
                start_idx = i * interval
                end_idx = len(data) if i == (num_intervals - 1) else start_idx + interval
                ax = fig.add_subplot(gs[var_pos+i])
                ax.plot(np.arange(start_idx, end_idx), data[start_idx:end_idx], label=f"{var_name} [{start_idx}, {end_idx}]")
                ax.set_title(f"{var_name} [{start_idx}, {end_idx}]")
                ax.set_xlabel("Time")
                ax.set_ylabel(var_name)
                ax.legend()
            var_pos += 1
                
        plt.suptitle(title, fontsize=16)
        plt.tight_layout()
        plt.show()
    else: raise ValueError("No variable proposed for plotting")

# %% ../nbs/mplots.ipynb 36
def plot_dataFrame_compareSubsequences(
    title, df, var, subsequence_len, seq1_init, seq2_init, 
    title_fontsize = '30',
    others_fontsize='20'
):
    fig, axs = plt.subplots(2)
    fig.subplots_adjust(hspace=0.4) 
    plt.suptitle(title, fontsize=title_fontsize)
    var_name = df.columns[var]
    axs[0].set_ylabel(var_name, fontsize=others_fontsize)
    axs[0].plot(df[var_name], alpha=0.5, linewidth=1)
    axs[0].plot(df[var_name].iloc[seq1_init:seq1_init+subsequence_len])
    axs[0].plot(df[var_name].iloc[seq2_init:seq2_init+subsequence_len])
    rect = Rectangle((seq1_init, 0), subsequence_len, 40, facecolor='lightgrey')
    axs[0].add_patch(rect)
    axs[0].set_xlabel("Index", fontsize=others_fontsize)

    rect = Rectangle((seq2_init, 0), subsequence_len, 40, facecolor='lightgrey')
    axs[0].add_patch(rect)
    axs[1].set_xlabel("Relative Index (subsequence)", fontsize=others_fontsize)
    axs[1].set_ylabel(var_name, fontsize=others_fontsize)
    axs[1].plot(df[var_name].values[seq1_init:seq1_init+subsequence_len], color='C1')
    axs[1].plot(df[var_name].values[seq2_init:seq2_init+subsequence_len], color='C2')
    plt.show()
    

# %% ../nbs/mplots.ipynb 38
def df_plot_colored_variables(df):
    # Show time series plot
    fig, ax = plt.subplots(1, figsize=(15,5), )
    cmap = matplotlib.colormaps.get_cmap('viridis')
    #df.plot(color=cmap(0.05), ax=ax) # or use colormap=cmap
    df.plot(colormap=cmap, ax=ax) # or use colormap=cmap
    # rect = Rectangle((5000, -4.2), 3000, 8.4, facecolor='lightgrey', alpha=0.5)
    # ax.add_patch(rect)
    plt.tight_layout()
    plt.legend()
    display(plt.show())

# %% ../nbs/mplots.ipynb 39
def plot_df_with_intervals_and_colors(title, df, interval=10000):
    num_variables = len(df.columns)
    num_intervals = len(df) // interval + 1  # Calcula el número necesario de intervalos/subplots

    fig = plt.figure(figsize=(10, num_intervals * 3 * num_variables))  # Ajusta el tamaño del plot
    gs = GridSpec(num_intervals * num_variables, 1)
    
    cmap = matplotlib.colormaps.get_cmap('viridis')

    for var_num, var in enumerate(df.columns):
        data = df[var]
        for i in range(num_intervals):
            ax = fig.add_subplot(gs[var_num * num_intervals + i])
            start_idx = i * interval
            end_idx = start_idx + interval

            if i == num_intervals - 1:  # Ajusta el último intervalo para incluir todos los datos restantes
                end_idx = len(data)

            color = cmap(var_num / num_variables)  # Asigna un color basado en la variable
            ax.plot(np.arange(start_idx, end_idx), data[start_idx:end_idx], label=f"{var} [{start_idx}, {end_idx}]", color=color)
            ax.set_title(f"{var} [{start_idx}, {end_idx}]")
            ax.set_xlabel("Index")
            ax.set_ylabel(var)
            ax.legend()

    plt.suptitle(title, fontsize=16)
    plt.tight_layout()
    plt.show()

# %% ../nbs/mplots.ipynb 41
def make_symmetric_(mat : np.array(float)) -> None:
    """ Ensures down-left triangle equals to up-right triangle """
    for i in range(len(mat)):
       mat[i:,i] = mat[i,i:]
def check_symmetric(mat : np.array(float)) -> bool:
    """ Check wether if down-left triangle equals to up-right triangle """
    sym = True
    i = 0
    while (i < len(mat) and sym):
        sym = np.array_equal(mat[i:,i], mat[i,i:])
        i+=1
    return sym


# %% ../nbs/mplots.ipynb 44
def moving_mean(a, w):
  result = np.zeros((len(a) - w + 1,))
  p = a[0]
  s = 0
  for i in range(1, w):
    x = p + a[i]
    z = x - p
    s += (p - (x - z)) + (a[i] - z)
    p = x
  
  result[0] = (p + s) / w

  for i in range(w, len(a)):
    x = p - a[i - w]
    z = x - p
    s += (p - (x - z)) - (a[i - w] + z)
    p = x

    x = p + a[i]
    z = x - p
    s += (p - (x - z)) + (a[i] - z)
    p = x
    result[i - w + 1] = (p + s) / w

  return result
def sum_of_squared_differences(a, means, w):
  result = np.zeros((len(a) - w + 1,))
  for i in range(len(a) - w + 1):
    vals = a[i:i+w] - means[i]
    vals = vals * vals
    result[i] = np.sum(vals)
  return result
def get_precomputes(T, m, nanvalues):
  flatness_epsilon = 1e-13
  n = len(T) - m + 1;
  df = np.zeros((n,))
  dg = np.zeros((n,))

  means = moving_mean(T,m)

  norms = sum_of_squared_differences(T, means, m)

  for i in range(n):
    if nanvalues[i]:
      norms[i] = np.nan
    elif norms[i] <= flatness_epsilon:
      norms[i] = np.nan
    else:
      norms[i] = 1.0 / math.sqrt(norms[i])

  for i in range(n-1):
    df[i] = (T[i + m] - T[i]) / 2.0;
    dg[i] = (T[i + m] - means[i + 1]) + (T[i] - means[i]);

  return means, norms, df, dg
def convert_non_finite_to_zero(T, m):
  timeseries_clean = np.zeros((len(T),))
  nanvals = np.zeros((len(T) - m + 1,))
  steps_since_last_nan = m
  for i in range(len(T)):
    if np.isfinite(T[i]):
      timeseries_clean[i] = T[i]
    else:
      steps_since_last_nan = 0
      timeseries_clean[i] = 0
    if i >= m - 1:
      nanvals[i - m + 1] = steps_since_last_nan < m
    steps_since_last_nan += 1
  return timeseries_clean, nanvals
# Computes the distance matrix using the diagonal update method used in SCAMP
def distance_matrix(a,b,w):
    has_b = True
    if b is None:
        has_b = False
        b = a
    na = len(a) - w + 1
    if not has_b:
        nb = na
    else:
        nb = len(b) - w + 1
    out = np.ones((nb,na)) * -2


    a, nan_a = convert_non_finite_to_zero(a,w)
  
    if has_b:
      b, nan_b = convert_non_finite_to_zero(b,w)
    else:
      b = a

    mua, siga, dfa, dga = get_precomputes(a,w,nan_a)
    if not has_b:
        mub = mua
        sigb = siga
        dfb = dfa
        dgb = dga
    else:
        mub, sigb, dfb, dgb = get_precomputes(b,w, nan_b)

    diagmax = na
    if not has_b:
        minlag = w // 4
    else:
        minlag = 0

    
    c = np.zeros((diagmax - minlag,)) 
    for diag in range(minlag,diagmax):
      c[diag-minlag] = np.sum((a[diag:diag+w]-mua[diag]) * (b[:w]-mub[0]))
    
    for offset in range(nb-minlag):
      result = c*(sigb[offset]*siga[minlag+offset:])
      out[offset, minlag+offset:] = result
      if not has_b:
        out[minlag+offset:, offset] = result
      x = c + dfb[offset] * dga[minlag+offset:] + dfa[minlag+offset:]*dgb[offset]
      c = x[:-1]
    if has_b:
      diagmax = nb
      c = np.zeros((diagmax - minlag,)) 
      for diag in range(minlag,diagmax):
        c[diag-minlag] = np.sum((b[diag:diag+w]-mub[diag]) * (a[:w]-mua[0]))
      for offset in range(na-minlag):
        result = c*(siga[offset]*sigb[minlag+offset:])
        out[minlag+offset:, offset] = result
        x = c + dfa[offset] * dgb[minlag+offset:] + dfb[minlag+offset:]*dga[offset]
        c = x[:-1]

    out[np.isnan(out)] = -2
    return out

# %% ../nbs/mplots.ipynb 46
@dataclass
class DistanceProfile:
    """ Vector of distances between each subsequence in TA and a reference sequence TB"""
    # Data to compare
    data  : List [ float ]  = None
    # Reference data
    data_b : List [ float ] = None
    data_b_i        : int   = 0
    self_join       : bool  = True
    subsequence_len : int   = 0
    # Distance profile
    distances: List[float]  = field(default_factory=list),
    # Figure
    mplot                   = None,
    # Method used for building the DistanceProfile
    method                  = 'naive',
    computation_time: float = 0.0
    
    def compute(
        self        : 'DistanceProfile',
        d           : Callable  = euclidean_distance,
        method      : str       = 'naive',
        fig_size    : tuple     = (12, 10),
        print_flag  : bool      = False,
        plot_flag   : bool      = True,
        time_flag   : bool      = False
    ) -> Tuple[ List [ float ], ut.Time ]:
        """ Compute the Distance Profile """    
        t = None
        if time_flag:
            t = ut.Time(function=ut.funcname())
            t.start(print_flag)
        
        if ( self.subsequence_len is None ):
            self.subsequence_len = len(self.data_b)
        
        if (self.self_join): 
            if print_flag : print("--> Self join", "TB_i", self.data_b_i, "TA", self.data)
            self.data_b = self.data[self.data_b_i:self.data_b_i+self.subsequence_len]

        if print_flag:
            print("TA: ", self.data)
            print("TB: ", self.data_b)
        
        n = len(self.data)
        m = self.subsequence_len
        expected_size = n - m + 1

        if print_flag: print("Expected_size", expected_size)
        self.method = method
        match self.method:
            case 'stumpy.mass':
                if print_flag: print("--> Using stumpy.mass")
                if (d.__name__ == 'z_normalized_euclidean_distance'):
                    if print_flag: print("Normalized")
                    self.distances = stump.core.mass(
                        Q = self.data_b.astype(np.float64),
                        T = self.data.astype(np.float64)
                    )
                else:
                    if print_flag: print("Non-Normalized")
                    self.distances = stump.core.mass(
                        Q = self.data_b.data.astype(np.float64),
                        T = self.data.astype(np.float64),
                        normalize = False
                    )
            case _:
                print("--> Using naive made distance profile [ default | Not recommended ]")
                self.distances = np.zeros(expected_size)
                for i in range(expected_size):
                    vector_a = self.data_b
                    vector_b = self.data[i:i+m]
                    if print_flag: 
                        print(f"[DP] Computing distance {i} \nTA: {self.data},\nTB: {self.data_b}")
                    self.distances[i] = d (
                        vector_a    = vector_a,
                        vector_b    = vector_b,
                        print_flag  = print_flag,
                        time_flag   = time_flag
                    )[0]


                #self.distances = np.array([
                #    d(
                #        vector_a = deepcopy(self.data_b),
                #        vector_b = deepcopy(self.data[i:i+m]),
                #        print_flag = print_flag,
                #        time_flag = time_flag
                #    )
                #    [0] for i in range(expected_size)
                #]
                #)
            
        if (self.self_join):
            if print_flag: print("--> Self join")
            self.distances[self.data_b_i] = np.nan
            
        if plot_flag: 
            if print_flag: print("--> plot")
            plot_subsequences(
                self.data,
                self.data_b,
                self.data_b_i, 
                len(self.data_b), 
                self.distances,
                fig_size = fig_size
            )
        if time_flag: 
            t.end(print_flag)
            t.show()
            self.computation_time = t.time_total
        return self.distances, t
    
    def plot_subsequence_compared(
        self,
        sequence_i : int = 0,
        print_flag : bool = False,
        fig_width = 12
    ) -> None:
        if (self.data_b is None or self.self_join) :
            if print_flag: print("--> TB = TA")
            self.data_b = self.data
        n = len(self.data)
        m = self.subsequence_len
        expected_size = n - m + 1
        x_coords = range(n)
        if print_flag:
            print("expected size", expected_size)
            print("--> Getting height")
        fig_height_in = 0.59 *2 + 2
        fig, axs = plt.subplots(2, 1, figsize=(fig_width, fig_height_in), sharex=True)
        if print_flag: print("--> TB")
        TB_sub = self.data_b[self.data_b_i: m]
        if print_flag: print("TA", self.data, len(self.data))
        if print_flag: print("TB", self.data_b, len(self.data_b), " subsequence ", self.data_b_i, m, TB_sub)
        axs[0].plot(x_coords, self.data_b, label='Time Series')
        if print_flag : print("m", m, "TB_i", self.data_b_i, "TB_i+m", self.data_b_i+m)
        axs[0].plot(x_coords[self.data_b_i:self.data_b_i+m], TB_sub, color='darkgray', label='TB_reference')
        axs[0].legend()
        axs[0].set_title('Pairwise differences')

        if print_flag: print("--> TA")
        axs[1].plot(x_coords, self.data, label='TA')
        i = sequence_i
        axs[1].plot(x_coords[i:i+m], self.data[i:i+m], color='green', label='Subsequence' if i == 0 else "")
        axs[1].text(i + m/2, (min(self.data[i:i+m]) + max(self.data[i:i+m])) / 2, f"{self.distances[i]:.2f}", ha='center')
        axs[1].legend()
        axs[1].set_title('Euclidean distance ' + str(i))
        plt.tight_layout()
        plt.show()

# %% ../nbs/mplots.ipynb 52
@dataclass
class DistanceMatrix: 
    """ Similarity matrix """
    # -- Similarity Matrix
    distances: List[ List [ float ] ] = field(default_factory=list)
    # -- Time series A (Query Time Serie
    data: List [ float ]  = None
    # -- Reference sequence
    data_b : List [ float ]  = None
    ## -- If comparing to a subsequence of the own matrix
    self_join   : bool  = True
    data_b_i    : int   = 0
    # -- 
    subsequence_len : int = 1
    method : str = 'naive'
    computation_time : float = 0.0


    def load_data_from_matlab(
        self, 
        matrix : MatlabMatrix = None,
        filename : str = None,
        matname : str = None,
        smoothing_window_len : int = None,
        path : str = ".",
        numcol : int  = 0,
        force_smooth : bool = False,
        set_a_or_b : bool = True,
        print_flag : bool = False
    ) ->  List [ float ] :
        if matrix is None:
            matrix = MatlabMatrix(
                filename = filename, 
                matname = matname,
                smoothing_window_len = smoothing_window_len,
                path = path
            )
        matrix_data = matrix.load(
            numcol, print_flag, force_smooth, path
        )

        if (set_a_or_b):   
            if print_flag: print("Copy A")
            self.data = deepcopy(matrix_data)
        else: 
            if print_flag: print("Copy B")
            self.data_b = deepcopy(matrix_data)

        return matrix_data
        
    
    def compute(
        self                : 'DistanceProfile',
        method              : 'str'     = 'naive',
        d                   : Callable  = z_normalized_euclidean_distance,
        ensure_symetric     : bool      = True,
        #--- Scamp
        mheight             : int       = None,
        mwidth              : int       = None,
        #--- Octave functions expected parameters ---
        min_lag             : int       = 0, #May be needed if SimMat is used
        #--- may be needed by runsplat, splat & piecewiseSplat
        multiresolution     : int       = 0,
        calibration         : int       = 0,
        piecewise           : bool      = False,
        patch_size          : int       = 5000, #Size of patches to compute (the final matrix, similar to mheight, mwidht)
        print_flag          : bool      = False,
        plot_flag           : bool      = False,
        time_flag           : bool      = True,
        allow_experimental  : bool      = True, #Allows the use of experimental code
        parallel            : bool      = True,
        threads             : int       = 4
    ) -> Tuple [ List [ List [ float ] ], Optional [ ut.Time ] ] :
        t = None

        complete                    = self.data_b == None
        n                           = len(self.data)
        rows                        = n - self.subsequence_len + 1
        if (complete): 
            columns = rows
            reference_seq = self.data
        else: 
            reference_seq = self.data_b
            columns = len(reference_seq) + 1
        self.distances = np.empty((rows, columns))
        if time_flag: 
            timer = ut.Time()
            timer.start()

        DP_AB : DistanceProfile = None

        match method:
            case 'stump':
                if print_flag: print("--> Stump")
                if self.data_b is None: 
                    data_b = deepcopy(self.data)
                else: 
                    data_b = deepcopy(self.data_b)
                DP_AB = DistanceProfile(self_join = self.self_join, subsequence_len = self.subsequence_len )
                if not parallel:
                    print ("Not parallel")
                    DP_AB.data            = self.data
                    DP_AB.data_b          = deepcopy(data_b)
                    DP_AB.data_b_i        = 0
        
                
                def compute_distance_i(i : int) -> List [ float ]:
                    nonlocal DP_AB

                    if parallel:
                        print(f"Creating {i} ~ DP_AB")
                        DP_AB_ = DistanceProfile(
                            data            = deepcopy(self.data),
                            data_b          = deepcopy(data_b),
                            data_b_i        = i,
                            self_join       = self.self_join, 
                            subsequence_len = self.subsequence_len
                        )
                        print(f"data {i} ~ {DP_AB_.data.shape}")
                        print(f"data_b {i} ~ ", DP_AB_.data_b.shape)
                    else:
                        DP_AB_ = DP_AB
                        DP_AB_.data_b_i = i
                        DP_AB.data_b = data_b

                    DP_AB_.compute(
                        print_flag=print_flag,
                        plot_flag=plot_flag,
                        d=d,
                        method='stumpy.mass',
                    )

                    print(f"DP {i} = {DP_AB_.distances}")
                    print(f"DP {i} ~ {DP_AB_.distances.shape}")
                    
                    return DP_AB_.distances
                
                if (parallel):
                    print("Parallel")
                    with ThreadPoolExecutor(max_workers=threads) as executor:
                        distances = list(executor.map(compute_distance_i, range(rows)))
                    self.distances = np.array(distances)
                else:
                    for i in range(rows):
                        print(f"[ DistanceMatrix ] | Compute row {i} / {rows} stump")
                        self.distances[i] = compute_distance_i(i)
                        
            case 'scamp': 
                if print_flag: print("--> Scamp")
                if complete and allow_experimental:
                    if print_flag: 
                        print("--> selfjoin_matrix", self.distances.shape)

                        if mheight is None: 
                            mheight = n - self.subsequence_len + 1
                        if mwidth is None:
                            mwidth =  n - self.subsequence_len + 1
                        self.distances = scamp.selfjoin_matrix(
                            self.data, 
                            self.subsequence_len,
                            gpus    = [],
                            mheight = mheight,
                            mwidth  = mwidth,
                            verbose = print_flag,
                            pearson = True
                        )
                    if print_flag: print("selfjoin_matrix -->", self.distances.shape)
                else:
                    self.distances = distance_matrix(
                            self.data, #a_data
                            reference_seq,  #b_data
                            self.subsequence_len #windos
                        )
            case 'octave-mpx':
                self.distances = octave.SimMat(
                    self.data,
                    self.subsequence_len,
                    self.data_b,
                    min_lag,
                    nout=1
                )
            case 'octave-runsplat':
                self.distances = octave.runsplat(
                    self.subsequence_len,
                    self.data, 
                    self.data_b,
                    multiresolution, 
                    calibration, 
                    display_mplot = False,
                    piecewise = True, 
                    patch_size = patch_size
                )
            case 'octave-splat':
                print("multiresolution before octave call", multiresolution)
                args = {
                    'timeSeriesA': self.data, 
                    'subseqLen': self.subsequence_len,
                    'timeSeriesB': self.data_b, 
                    #displat_mplot setted up to false as default because I couldn't get the plot shown in Jupyter Notebook... waiting for python implementation. (Zack!)
                    'plotting': False,
                    'multiresolution': multiresolution,
                    'calibration': calibration
                }
                self.distances = octave.SPLAT(
                    self.data, self.subsequence_len, 
                    self.data_b, False, 
                    multiresolution, calibration
                )
            case 'octave-piecewiseSplat':
                self.distances = octave.piecewiseSplat(
                    self.data,
                    self.subsequence_len, 
                    patch_size,
                    False, 
                    self.data_b
                )
            case _: #default naive
                if print_flag: print("--> Invalid method. Using naive [default]")
                if ( self.self_join ) : self.data_b = deepcopy(self.data)

                DP_AB = DistanceProfile(
                    data        = deepcopy(self.data),
                    data_b      = deepcopy(self.data_b),
                    self_join   = self.self_join, 
                    subsequence_len = self.subsequence_len
                )

                for i in range(rows):
                    DP_AB.data_b   = deepcopy(self.data_b)
                    DP_AB.data_b_i = i

                    if print_flag: 
                        print( f"[ DistanceMatrix ] | Compute row {i}" )
                        print( f"TA{DP_AB.data}" )
                        print( f"TB{DP_AB.data_b}" ) 
                        print( f"len{DP_AB.subsequence_len}" )
                    
                    DP_AB.compute (
                        print_flag = print_flag,
                        plot_flag  = plot_flag,
                        d          = d,
                        method     = 'naive',

                    )
                    self.distances[i] = DP_AB.distances
                        
        if time_flag: 
            timer.end()
            self.computation_time = timer.duration() 
        if print_flag: 
            if time_flag: 
                print(f"matrix profile {duration} seconds -->")
            else: 
                print("matrix profile -->")
        #TODO: En mplot_explorer se asegura de que la matriz sea simétrica respecto a la diagonal
        # y tiene sentido, cuando es cuadrada, pero.... siendo así... 
        # ¿Por qué la guardo entera? Ya he guardado antes matrices simétricas como triangulares...
        # -> Pensar en cómo afectaría. Tiene sentido para el caso en que rows = columns.
        if (ensure_symetric and rows == columns) : 
            make_symmetric_(self.distances)
        return self.distances    

# %% ../nbs/mplots.ipynb 56
def plot_motif(df, motif_idx, nearest_neighbor_idx, variable_name, title, padding = 1000, m = 1, mp = None):
    fig, axs = plt.subplots(2, sharex = True, gridspec_kw={'hspace': 0})
    plt.suptitle('Motif (Pattern) Discovery', fontsize='30')
    padding = min(padding, len(df[variable_name].values) // 2)

    # Calcula los límites para hacer zoom
    x_min = max(min(motif_idx, nearest_neighbor_idx) - padding, 0)
    x_max = min(max(motif_idx, nearest_neighbor_idx) + padding, len(df[variable_name].values))

    axs[0].plot(df[variable_name].values)
    axs[0].set_xlim([x_min, x_max])  # Aplica el zoom aquí
    axs[0].set_ylabel(title, fontsize='20')
        
    axs[0].set_ylabel(title, fontsize='20')
    rect = Rectangle((motif_idx, 0), m, 40, facecolor='lightgrey')
    axs[0].add_patch(rect)
    rect = Rectangle((nearest_neighbor_idx, 0), m, 40, facecolor='lightgrey')
    axs[0].add_patch(rect)
    axs[1].set_xlabel('Time', fontsize ='20')
    axs[1].set_ylabel('Matrix Profile', fontsize='20')
    axs[1].axvline(x=motif_idx, linestyle="dashed")
    axs[1].axvline(x=nearest_neighbor_idx, linestyle="dashed")
    axs[1].plot(mp)
    plt.show()

# %% ../nbs/mplots.ipynb 57
def plot_motif_separated(df, motif_idx=0, nearest_neighbor_idx=0, variable_name="", title="", padding=1000, m=1, mp=None):
    fig, axs = plt.subplots(4, sharex=False, figsize=( 12, 5), gridspec_kw={'hspace': 0.5})
    plt.suptitle('Motif (Pattern) Discovery', fontsize='20')
    
    padding = max(m, min(padding, len(df[variable_name].values) // 2))

    x_min_motif = max(motif_idx - padding, 0)
    x_max_motif = min(motif_idx + padding, len(df[variable_name].values))

    axs[0].plot(df[variable_name].values)
    axs[0].set_xlim([x_min_motif, x_max_motif])
    axs[0].set_ylabel(title, fontsize='10')
    rect_motif = Rectangle((motif_idx, df[variable_name].min()), m, df[variable_name].max() - df[variable_name].min(), facecolor='lightgrey')
    axs[0].add_patch(rect_motif)

    axs[1].plot(mp)
    axs[1].set_xlim([x_min_motif, x_max_motif])
    axs[1].set_xlabel('Time', fontsize='10')
    axs[1].set_ylabel('MP - Min', fontsize='10')
    axs[1].axvline(x=motif_idx, linestyle="dashed")

    x_min_neighbor = max(nearest_neighbor_idx - padding, 0)
    x_max_neighbor = min(nearest_neighbor_idx + padding, len(df[variable_name].values))

    axs[2].plot(df[variable_name].values)
    axs[2].set_xlim([x_min_neighbor, x_max_neighbor])
    axs[2].set_ylabel(title, fontsize='10')
    rect_neighbor = Rectangle((nearest_neighbor_idx, df[variable_name].min()), m, df[variable_name].max() - df[variable_name].min(), facecolor='lightgrey')
    axs[2].add_patch(rect_neighbor)

    axs[3].plot(mp)
    axs[3].set_xlim([x_min_neighbor, x_max_neighbor])
    axs[3].set_xlabel('Time', fontsize='10')
    axs[3].set_ylabel('MP-max', fontsize='10')
    axs[3].axvline(x=nearest_neighbor_idx, linestyle="dashed")

    plt.show()

# %% ../nbs/mplots.ipynb 58
@dataclass
class MatrixProfile:
    """ Class for better usability of Matrix Profile inside deepVATS"""
    #---- Main information of the matrix profile ----#
    data        : List [ float ] = None
    data_b      : List [ float ] = None
    self_join   : bool           = True
    distances   : List[ float ]  =  field(default_factory=list)

    # Execution information
    computation_time: float = 0.0
    
    #-- Size used for the MP computation
    subsequence_len: int = 0
    #-- Wether if stumpy or SCAMP or other method have been used 
    method: str = 'naive'
    #-- Interactive Plot
    current_index_pos_plot  : int  = 0

    
    #-- Looking for motifs & neighbors
    # Ordered array for finding motifs/anomalies
    index : List[int] =  field(default_factory=list)
    # Nearest neighbours in the past (if computed)
    index_left : List[int] =  field(default_factory=list)
    # Nearest neighbours in the future (if computed)
    index_right: List[int] = field(default_factory=list)

    #--- Save the main motif index and its neighbors' index    
    motif_idx: int = 0
    motif_nearest_neighbor_idx: int = 0
    motif_nearest_neighbor_idx_left: int = 0
    motif_nearest_neighbor_idx_right: int = 0

    #--- Save the main anomaly index and its neighbors' index
    discord_idx: int = 0
    discord_nearest_neighbor_idx: int = 0
    discord_nearest_neighbor_idx_left: int = 0
    discord_nearest_neighbor_idx_right: int = 0
    

    def plot(
        self        : 'MatrixProfile', 
        figsize     : Tuple [int, int]  = (10,8),
        print_flag  : bool              = False
    ):
        n           = len(self.data)
        x_coords    = range(n)
        y_coords    = self.data
        fig, (ax1, ax2) = plt.subplots(
            2, 1, 
            figsize=figsize, 
            sharex=True
        )  

        ax1.plot(x_coords, y_coords, label='Time Series')
        ax1.scatter(x_coords, y_coords, color='red') 
        ax1.set_title('Time Series')
        ax1.set_xlabel('Index (time)')
        ax1.set_ylabel('Value')

        ax2.plot(self.distances, label='Matrix Profile')
        ax2.set_title('Matrix Profile')
        ax2.set_xlabel('Subsequence Index')
        ax2.set_ylabel('Distance')

        ax1.legend()
        ax2.legend()
        plt.tight_layout()
        plt.show()
        
    def plot_interactive(
        self        : 'MatrixProfile', 
        figsize     : Tuple [ int, int ]  = (10, 4), 
        print_flag  : bool                = False
    ):
        
        self.current_index_pos_plot
        self.distances_ordered = np.argsort(self.distances)
    

        fig, (ax1, ax2) = plt.subplots(2, 1, figsize=figsize, sharex=True)

        
        def update(pos : int = 0, add : int = 0):
            nonlocal print_flag 
            if print_flag: print("Before: Pos", pos, "Add", add)
            
            self.current_index_pos_plot = pos+add
            
            if (self.current_index_pos_plot < 0): self.current_index_pos_plot = len(self.distances) - 1
            if (self.current_index_pos_plot >= len(self.distances)): self.current_index_pos_plot = 0
            
            selected_index = self.distances_ordered[self.current_index_pos_plot]
            
            if print_flag: 
                print("After: Pos", self.current_index_pos_plot, "Selected index", selected_index)
                print("Distances: ", self.distances)
            
            ax1.clear()
            ax1.plot(self.distances, label='Matrix Profile')
            ax1.scatter(selected_index, self.distances[selected_index], color='red')

            ax1.text(0.5, 0.9, f'Posición actual: {self.current_index_pos_plot} de {len(self.distances_ordered) - 1}', horizontalalignment='center', verticalalignment='center', transform=ax1.transAxes)

            ax1.set_ylabel('Distance')
            ax1.legend()
            
            ax2.clear()
            ax2.plot(self.data, label='Time Series', color='lightgrey')
            ax2.axvline(x=selected_index, color='grey', linestyle='--')
            ax2.scatter(selected_index, self.data[selected_index], color='red')
            ax2.plot(range(selected_index, selected_index + self.subsequence_len),
                 self.data[selected_index:selected_index + self.subsequence_len],
                 color='orange', label=f'Subsequence {selected_index}')  # Subsecuencia en naranja
            ax2.set_xlabel('Index (time)')
            ax2.set_ylabel('Value')
            ax2.legend()
            
            ax2.set_xlabel('Index (time)')
            return pos

        
        first_button = widgets.Button(description='First Min => Motif')
        mid_button = widgets.Button(description='Mid')
        last_button = widgets.Button(description='Last Max => Discord')
        next_button = widgets.Button(description='Next')
        prev_button = widgets.Button(description='Previous')

        first_button.on_click(lambda b: update(0, 0))
        mid_button.on_click(lambda b: update(len(self.distances) // 2, 0))
        last_button.on_click(lambda b: update(-1,0))
        
        next_button.on_click(lambda b: update(self.current_index_pos_plot, 1))
        prev_button.on_click(lambda b: update(self.current_index_pos_plot, -1))

        display(
            widgets.VBox(
                [widgets.HBox([first_button, mid_button, last_button]),
                 widgets.HBox([prev_button, next_button])]
            )
        )

        update(0,0)

    def get_ordered_idx(self, pos):
        mp_sorted = np.argsort( self.distances )
        return mp_sorted[pos]
        
    def get_motif_idx(self : 'MatrixProfile', print_flag : bool = False): 
        motif_idx = self.get_ordered_idx(0)
        self.motif_idx = motif_idx
        if print_flag: print("motif id", motif_idx, "index ~ ", len(self.index))
        self.motif_nearest_neighbor_idx = self.index[motif_idx]
        
        if ( self.method == 'stump' or self.method == 'gpu_stump'):
            self.motif_nearest_neighbor_idx_left = self.index_left[motif_idx]
            self.motif_nearest_neighbor_idx_right = self.index_right[motif_idx]
        return self.motif_idx, self.motif_nearest_neighbor_idx, self.motif_nearest_neighbor_idx_left, self.motif_nearest_neighbor_idx_right
    
    def get_anomaly_idx(self : 'MatrixProfile', print_flag : bool = False ): 
        discord_idx = self.get_ordered_idx(-1)
        self.discord_idx = discord_idx
        self.discord_nearest_neighbor_idx = self.index[discord_idx]
        if print_flag: print("motif id", discord_idx, "index ~ ", len(self.index))
        if ( self.method == 'stump' or self.method == 'gpu_stump'):
            self.discord_nearest_neighbor_idx_left = self.index_left[discord_idx]
            self.discord_nearest_neighbor_idx_right = self.index_right[discord_idx]
            
        return self.discord_idx, self.discord_nearest_neighbor_idx, self.discord_nearest_neighbor_idx_left, self.discord_nearest_neighbor_idx_right
    
    def plot_id(
        self, 
        ta_name = 'Time Serie TA', 
        tb_name = 'Time Serie TB',
        idx = 0, 
        nearest_neighbor_idx = 0, 
        title_fontsize = '30', 
        other_fontsize = '20',
        figsize = (10, 8),
        title = 'Motif (Pattern) Discovery'
    ): 
        fig, axs = plt.subplots(3, sharex=True, gridspec_kw={'hspace': 0.4}, figsize = figsize)
        plt.suptitle(title + ' | ' + self.method , fontsize=title_fontsize)
        #--- Plot TA & Motif sequence
        axs[0].plot(self.data)
        axs[0].set_ylabel(ta_name, fontsize=other_fontsize)
        rect = Rectangle((idx, 0), self.subsequence_len, 40, facecolor='lightgrey')
        axs[0].add_patch(rect)
        #-- Plot TB & nearest neighbour sequence
        if (self.data_b is None):
            axs[1].plot(self.data)
        else: 
            axs[1].plot(self.data_b)
        axs[1].set_ylabel(tb_name, fontsize=other_fontsize)
        rect = Rectangle((nearest_neighbor_idx, 0), self.subsequence_len, 40, facecolor='lightgrey')
        axs[1].add_patch(rect)
        #--- Plot Matrix Profile
        axs[2].set_xlabel('Index', fontsize =other_fontsize)
        axs[2].set_ylabel('Matrix Profile', fontsize=other_fontsize)
        axs[2].axvline(x=idx, linestyle="dashed", color = "black")
        axs[2].axvline(x=nearest_neighbor_idx, linestyle="dashed", color="red")
        axs[2].plot(self.distances)
        plt.show()
    
    def __str__(self):
        return f"MP: {self.distances}\nIds: {self.index}\nIds_left: {self.index_left}\nIds_right: {self.index_right}\nComputation_time: {self.computation_time}\nsubsequence_len: {self.subsequence_len}\nmethod: {self.method}"

# %% ../nbs/mplots.ipynb 60
def matrix_profile(
    data            : List [ float ], 
    subsequence_len : int, 
    data_b          : Optional [ List [ float ] ]   = None,
    self_join       : bool                          = True,
    method          : str                           = 'naive', 
    d               : Callable                      = z_normalized_euclidean_distance,
    threads         : int                           = 4, # For scamp abjoin
    gpus            : int                           = [], # For scamp abjoin
    print_flag      : bool                          = False, 
    debug           : bool                          = True, 
    time_flag           : bool                          = True,
    plot_flag       : bool                          = False
) -> Tuple [ List [ float ], List [ float ], List [ float], List[ float], Optional [ ut.Time ]]:
    """ 
    This function 
    Receives
    - data: a 1D-array representing a time series values (expected to be long)
    - subsequence_len: Matrix Profile subsequences length
    - method: wether to use stump or scamp algorithm
    - print_flag: for printing or not messages
    - debug: for adding some comprobations on GPUs usability
    - time_flag: for getting or not the execution time for the implementation analysis
    - Threads: number of threads for scamp multithread execution
    - GPUs: id of the GPUs to be used for scamp execution

    and returns 
    - mp: matrix profile
    - index: patterns indices
    - index_left: nearest neighbors in the past
    - index_right: nearest neigbhbors in the future
    - Optional: execution time
    """
    
    if print_flag: print("--> matrix profile")
    #Execution time
    duration = 0.0
    # Matrix Profile (distances)
    mp = []
    # Patterns indices (position within the MP)
    index = []
    index_left = []
    index_right = []

    
    #-- Start timing
    if time_flag: 
        timer = ut.Time()
        timer.start()

    #-- Select the method
    match method:
        case 'stump': # Not tested
            #-- use stumpy.gpu_stump
            normalize = (d.__name__ == 'z_normalized_euclidean_distance')
            if print_flag: 
                print("--> Stump (CPU)")
                print("MP | Compute | Using stumpy.stump | normalize?", normalize)
            
            mp = stump.stump(
                T_A = data.astype(np.float64), 
                m = subsequence_len, 
                T_B = data_b,
                ignore_trivial = True,
                normalize = normalize
            )
            #-- Save in separated columns for compatibility with SCAMP
            index = mp[:,1]
            index_left = mp[:,2]
            index_right = mp[:,3]
            mp = mp[:,0]
        
        case 'stump_gpu': # You are suposed to use this or scamp
            if print_flag: print("--> Stump (GPU)")
            #-- Matrix profile
            normalize = (d.__name__ == 'z_normalized_euclidean_distance')
            T_A = data.astype(np.float64)
            T_B = data_b
            if not T_B is None : 
                print("TB provided", T_B)
                T_B = T_B.astype(np.float64)
            mp = stump.gpu_stump(
                T_A = T_A, 
                m = subsequence_len, 
                T_B = T_B,
                ignore_trivial = True,
                normalize = normalize
            )
            #-- Save in separate columns
            index = mp[:,1]
            index_left = mp[:,2]
            index_right = mp[:,3]
            mp = mp[:,0]
            
        case 'scamp': # Yo should use GPU in Large TS
            if print_flag: print("--> Scamp")
            if debug: 
                print("Check gpu use")
                has_gpu_support = scamp.gpu_supported()
                print(has_gpu_support)
            #-- Matrix profile & index. Nothing more to save
            if (data_b is None):
                mp, index = scamp.selfjoin(data, subsequence_len)
            else: 
                if print_flag: print("--> data_b provided => Executing abjoin")
                mp, index = scamp.abjoin(data, data_b, subsequence_len, threads, gpus)
        case _: #default naive
            if print_flag: print("--> Invalid method. Using naive approach [default]")
            if ( data_b is None or self_join ): 
                data_b = data
            n_a     = len(data)
            n_b     = len(data_b)
            m       = subsequence_len
            rows    = n_b-m+1
            columns = n_a-m+1

            if print_flag:
                print("TA ~ ", n_a)
                print("TB ~ ", n_b)
                print("m =", m)
                print("Size: ", "(", rows, ",", columns, ")")
        
            DP_AB : DistanceProfile = None
            mp = np.zeros(rows)
            for i in range(rows):
                DP_AB = DistanceProfile(data = data, data_b = data_b, data_b_i = i, self_join = self_join, subsequence_len = subsequence_len)
                DP_AB.compute(print_flag = print_flag, plot_flag = plot_flag, d = d)
                mp[i] = np.nanmin(DP_AB.distances)
            
    if time_flag: 
        timer.end()
        duration = timer.duration() 
    if print_flag: 
        if time_flag: 
            print(f"matrix profile {duration} seconds -->")
        else: 
            print("matrix profile -->")
    return mp, index, index_left, index_right, duration

# %% ../nbs/mplots.ipynb 71
@dataclass
class MatrixProfiles:
    matrix_profiles : List[ MatrixProfile ] = field( default_factory=list )
    data            : List[float]           = field( default_factory=list )
    data_b          : List[float]           = None
    
    subsequence_len: int = 0

    def append (self : 'MatrixProfiles', mp: MatrixProfile):
        self.matrix_profiles.append(deepcopy(mp))
        self.subsequence_len = mp.subsequence_len

    def compute(
        self, 
        method      : str       = 'scamp',  
        d           : Callable  = z_normalized_euclidean_distance,
        threads     : int       = 4,
        gpus        : List[int] = field( default_factory = list ),
        print_flag  : bool      = False, 
        debug       : bool      = False, 
        time_flag   : bool      = True
    ):
        """ 
        Computes the Matrix Profile for data & data_b arrays using subsequence_len length.
        Appends the resulting MP to the matrix_profiles list.
        """
        mp = MatrixProfile(
            data = self.data,
            subsequence_len=self.subsequence_len,
            data_b = None
        )
        mp.compute(
            method          = method, 
            d               = d,
            threads         = threads,
            gpus            = gpus,
            print_flag      = print_flag, 
            debug           = debug,
            time_flag       = time_flag
        )
        
        mp.method = method
        self.matrix_profiles.append(mp)
        
        if print_flag: 
            print("MPs | compute -> Subsequence len outside: ", self.subsequence_len)
            print("MPs | compute -> Subsequence len inside: ", mp.subsequence_len)
            print("MPs | compute -> method outside: ", self.matrix_profiles[-1].method)
            print("MPs | compute -> method inside: ", mp.method)
        return mp
    
    def plot(self, ids = []):
        if ids == []: ids = range(len(self.matrix_profiles))
        num_plots = len(ids)+1
        fig = plt.figure(figsize=(10, 6))
        gs = GridSpec(num_plots, 1, height_ratios=[1] + [4] * (num_plots -1))
        # Serie temporal
        ax1 = fig.add_subplot(gs[0])
        ax1.plot(self.data, label="Data")
        ax1.set_title("Time Serie")
        ax1.legend()
        # MPlots
        for i in ids:
            ax2 = fig.add_subplot(gs[i+1], sharex=ax1)
            mp_values = self.matrix_profiles[i].matrix_profile.astype(float)
            ax2.imshow(mp_values.reshape(-1, 1).T, aspect='auto', origin='lower', cmap='hot', extent=(0, len(self.data), 0, self.subsequence_len))
            ax2.set_title(f"MPlot - {i} - {self.matrix_profiles[i].method}")
        plt.tight_layout()
        plt.show()

    def get_ordered_idx(self, id, pos):
        mp_sorted = np.argsort( self.matrix_profiles[id].matrix_profile )
        return mp_sorted[pos]
        
    def get_motif_idx(self, id): 
        motif_idx = self.get_ordered_idx(id, 0)
        self.matrix_profiles[id].motif_idx = motif_idx
        self.matrix_profiles[id].motif_nearest_neighbor_idx = self.matrix_profiles[id].index[motif_idx]
        
        if ( self.matrix_profiles[id].method == 'stump' ):
            self.matrix_profiles[id].motif_nearest_neighbor_idx_left = self.matrix_profiles[id].index_left[motif_idx]
            self.matrix_profiles[id].motif_nearest_neighbor_idx_right = self.matrix_profiles[id].index_right[motif_idx]
        return self.matrix_profiles[id].motif_idx, self.matrix_profiles[id].motif_nearest_neighbor_idx, self.matrix_profiles[id].motif_nearest_neighbor_idx_left, self.matrix_profiles[id].motif_nearest_neighbor_idx_right
    
    def get_anomaly_idx(self, id): 
        discord_idx = self.get_ordered_idx(id, -1)
        self.matrix_profiles[id].discord_idx = discord_idx
        self.matrix_profiles[id].discord_nearest_neighbor_idx = self.matrix_profiles[id].index[discord_idx]
        
        if ( self.matrix_profiles[id].method == 'stump' ):
            self.matrix_profiles[id].discord_nearest_neighbor_idx_left = self.matrix_profiles[id].index_left[discord_idx]
            self.matrix_profiles[id].discord_nearest_neighbor_idx_right = self.matrix_profiles[id].index_right[discord_idx]
            
        return self.matrix_profiles[id].discord_idx, self.matrix_profiles[id].discord_nearest_neighbor_idx, self.matrix_profiles[id].discord_nearest_neighbor_idx_left, self.matrix_profiles[id].discord_nearest_neighbor_idx_right
    
    
    def plot_motif(
        self, 
        ts_name,
        id, 
        idx, 
        nearest_neighbor_idx, 
        title_fontsize = '30', 
        other_fontsize = '20'
    ): 
        fig, axs = plt.subplots(2, sharex=True, gridspec_kw={'hspace': 0.4})
        plt.suptitle('Motif (Pattern) Discovery | ' + self.matrix_profiles[id].method , fontsize=title_fontsize)

        axs[0].plot(self.data.values)
        axs[0].set_ylabel(ts_name, fontsize=other_fontsize)
        rect = Rectangle((idx, 0), self.subsequence_len, 40, facecolor='lightgrey')
        axs[0].add_patch(rect)
        rect = Rectangle((nearest_neighbor_idx, 0), self.subsequence_len, 40, facecolor='lightgrey')
        axs[0].add_patch(rect)
        axs[1].set_xlabel('Index', fontsize =other_fontsize)
        axs[1].set_ylabel('Matrix Profile', fontsize=other_fontsize)
        axs[1].axvline(x=idx, linestyle="dashed", color = "black")
        axs[1].axvline(x=nearest_neighbor_idx, linestyle="dashed", color="red")
        axs[1].plot(self.matrix_profiles[id].matrix_profile)
        plt.show()


# %% ../nbs/mplots.ipynb 100
@dataclass
class MatrixProfilePlot:
    """ Time series similarity matrix plot """
    
    similarity_matrix : DistanceProfile = None
    
    def compute_similarity_matrix(
        self,
        method = 'scamp',
        print_flag : bool = False,
        debug : bool = False, 
        time_flag : bool = True, 
        allow_experimental : bool = True,
        ensure_symetric : bool = True
    ) -> List [ List [ float ] ] :
        self.similarity_matrix.compute(
            method = method,
            print_flag = print_flag,
            debug = debug,
            time_flag = time_flag, 
            allow_experimental = allow_experimental,
            ensure_symetric = ensure_symetric
        )
            
            
    def plot(self, ts_name, method = 'Scamp'):
        fig = plt.figure(figsize=(10, 10))
        gs = GridSpec(2, 1, height_ratios=[1, 4])

        # Matrix Profile
        ax1 = fig.add_subplot(gs[0])
        ax1.plot(self.similarity_matrix.data, label="Time Serie")
        ax1.set_title(ts_name + " | " +  method)
        ax1.legend()

        # MPlot (Distance Profile)
        ax2 = fig.add_subplot(gs[1], sharex=ax1)
        # Utilizar 'imshow' para visualizar la matriz MPlot
        ax2.imshow(self.similarity_matrix.similarity_matrix, 
                   aspect='auto', origin='lower', cmap='hot', 
                   extent=(0, len(self.similarity_matrix.data) - self.similarity_matrix.subsequence_len, 
                           0, len(self.similarity_matrix.data) - self.similarity_matrix.subsequence_len)
                  )
        ax2.set_title("MPlot")
        ax2.set_xlabel('TA')
        ax2.set_ylabel('TB')

        plt.tight_layout()
        plt.show()

# %% ../nbs/mplots.ipynb 106
@dataclass
class MatrixProfilePlotCached:
    """ Time series similarity matrix plot using cache """
    
    similarity_matrix : DistanceProfile = None
    
    def compute_similarity_matrix(
        self,
        method = 'scamp',
        print_flag : bool = False,
        debug : bool = False, 
        time_flag : bool = True, 
        allow_experimental : bool = True,
        ensure_symetric : bool = True
    ) -> List [ List [ float ] ] :
        self.similarity_matrix.compute(
            method = method,
            print_flag = print_flag,
            debug = debug,
            time_flag = time_flag, 
            allow_experimental = allow_experimental,
            ensure_symetric = ensure_symetric
        )
            
            
    def plot(self, ts_name, method = 'Scamp'):
        fig = plt.figure(figsize=(10, 10))
        gs = GridSpec(2, 1, height_ratios=[1, 4])

        # Serie temporal
        ax1 = fig.add_subplot(gs[0])
        ax1.plot(self.similarity_matrix.data, label="Time Serie")
        ax1.set_title(ts_name + " | " +  method)
        ax1.legend()

        # MPlot
        ax2 = fig.add_subplot(gs[1], sharex=ax1)
        # Utilizar 'imshow' para visualizar la matriz MPlot
        ax2.imshow(self.similarity_matrix.similarity_matrix, 
                   aspect='auto', origin='lower', cmap='hot', 
                   extent=(0, len(self.similarity_matrix.data) - self.similarity_matrix.subsequence_len, 
                           0, len(self.similarity_matrix.data) - self.similarity_matrix.subsequence_len)
                  )
        ax2.set_title("MPlot")
        ax2.set_xlabel('TA')
        ax2.set_ylabel('TB')

        plt.tight_layout()
        plt.show()

# %% ../nbs/mplots.ipynb 108
eamonn_drive_mplots = {
    'insects0': {
        'id': '1qq1z2mVRd7PzDqX0TDAwY7BcWVjnXUfQ',
        'name': 'InsectData-fig11'
    }
}
