# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/mplots.ipynb.

# %% auto 0
__all__ = ['mplot_path', 'eamonn_drive_mplots', 'MatrixProfile', 'matrix_profile', 'compute', 'MatrixProfiles', 'plot_dataFrame',
           'plot_dataFrame_compareSubsequences', 'df_plot_colored_variables', 'plot_df_with_intervals_and_colors',
           'plot_motif', 'plot_motif_separated', 'GD_Mat', 'MatlabMatrix', 'moving_mean', 'sum_of_squared_differences',
           'get_precomputes', 'convert_non_finite_to_zero', 'distance_matrix', 'make_symmetric_', 'check_symmetric',
           'DistanceProfile', 'MatrixProfilePlot', 'MatrixProfilePlotCached']

# %% ../nbs/mplots.ipynb 4
## -- Deepvats
import dvats.load as load
import dvats.memory as mem
import dvats.utils as ut

## -- Matrix profile
import pyscamp as scamp
import stumpy as stump 
## -- Utilities
import os
import numpy as np
import pandas as pd
import datetime as dt
import math
import warnings

## -- Classes & types
from dataclasses import dataclass, field
from typing import List, Optional, Tuple
## -- Plotting
import matplotlib
import matplotlib.pyplot as plt
import matplotlib.dates as dates

from matplotlib.gridspec import GridSpec
from matplotlib.patches import Rectangle

from mpl_toolkits.axes_grid1 import ImageGrid
from copy import deepcopy
plt.style.use('https://raw.githubusercontent.com/TDAmeritrade/stumpy/main/docs/stumpy.mplstyle')


# %% ../nbs/mplots.ipynb 5
#-- "Importing" MPlots MATLAB code
from oct2py import octave
mplot_path = os.path.expanduser('~/work/nbs/mplot')
octave.addpath(mplot_path);
octave.chdir(mplot_path);
#%load_ext oct2py.ipython
octave.register_graphics_toolkit('fltk')
octave.graphics_toolkit('fltk')
octave.set(0, 'defaultfigurevisible', 'on');

# %% ../nbs/mplots.ipynb 11
@dataclass
class MatrixProfile:
    """ Class for better usability of Matrix Profile inside deepVATS"""
    #---- Main information of the matrix profile ----#
    #-- Matrix Profile (distance array)
    matrix_profile: List[float] =  field(default_factory=list)

    # Execution information
    computation_time: float = 0.0
    
    #-- Size used for the MP computation
    subsequence_len: int = 0
    #-- Wether if stumpy or SCAMP or other method have been used 
    method: str = ''
    
    #-- Looking for motifs & neighbors
    # Ordered array for finding motifs/anomalies
    index : List[int] =  field(default_factory=list)
    # Nearest neighbours in the past (if computed)
    index_left : List[int] =  field(default_factory=list)
    # Nearest neighbours in the future (if computed)
    index_right: List[int] = field(default_factory=list)

    #--- Save the main motif index and its neighbors' index    
    motif_idx: int = 0
    motif_nearest_neighbor_idx: int = 0
    motif_nearest_neighbor_idx_left: int = 0
    motif_nearest_neighbor_idx_right: int = 0

    #--- Save the main anomaly index and its neighbors' index
    discord_idx: int = 0
    discord_nearest_neighbor_idx: int = 0
    discord_nearest_neighbor_idx_left: int = 0
    discord_nearest_neighbor_idx_right: int = 0
    
    def __str__(self):
        return f"MP: {self.matrix_profile}\nIds: {self.index}\nIds_left: {self.index_left}\nIds_right: {self.index_right}\nComputation_time: {self.computation_time}\nsubsequence_len: {self.subsequence_len}\nmethod: {self.method}"

# %% ../nbs/mplots.ipynb 13
def matrix_profile(
    data, 
    subsequence_len, 
    data_b     = None,
    method     = 'scamp', 
    threads    = 4, # For scamp abjoin
    gpus       = [], # For scamp abjoin
    print_flag = False, 
    debug      = True, 
    timed      = True
):
    """ 
    This function 
    Receives
    - data: a 1D-array representing a time series values (expected to be long)
    - subsequence_len: Matrix Profile subsequences length
    - method: wether to use stump or scamp algorithm
    - print_flag: for printing or not messages
    - debug: for adding some comprobations on GPUs usability
    - timed: for getting or not the execution time for the implementation analysis
    - Threads: number of threads for scamp multithread execution
    - GPUs: id of the GPUs to be used for scamp execution

    and returns 
    - mp: matrix profile
    - index: patterns indices
    - index_left: nearest neighbors in the past
    - index_right: nearest neigbhbors in the future
    """
    
    if print_flag: print("--> matrix profile")
    #Execution time
    duration = 0.0
    # Matrix Profile (distances)
    mp = []
    # Patterns indices (position within the MP)
    index = []
    index_left = []
    index_right = []
    
    #-- Start timing
    if timed: 
        timer = ut.Time()
        timer.start()

    #-- Select the method
    match method:
        case 'stump': # Not tested
            #-- use stumpy.gpu_stump
            if print_flag: print("--> Stump (CPU)")
            mp = stump.stump(data, subsequence_len, data_b)
            #-- Save in separated columns for compatibility with SCAMP
            index = mp[:,1]
            index_left = mp[:,2]
            index_right = mp[:,3]
            mp = mp[:,0]
        
        case 'stump_gpu': # You are suposed to use this or scamp
            if print_flag: print("--> Stump (GPU)")
            #-- Matrix profile
            mp = stump.gpu_stump(data, subsequence_len, data_b)
            #-- Save in separate columns
            index = mp[:,1]
            index_left = mp[:,2]
            index_right = mp[:,3]
            mp = mp[:,0]
            
        case 'scamp': # Yo should use GPU in Large TS
            if print_flag: print("--> Scamp")
            if debug: 
                print("Check gpu use")
                has_gpu_support = scamp.gpu_supported()
                print(has_gpu_support)
            #-- Matrix profile & index. Nothing more to save
            if (data_b is None):
                mp, index = scamp.selfjoin(data, subsequence_len)
            else: 
                if print_flag: print("--> data_b provided => Executing abjoin")
                mp, index = scamp.abjoin(data, data_b, subsequence_len, threads, gpus)
        case _: #default scamp
            if print_flag: print("--> Invalid method. Using scamp [default]")
            if debug: 
                has_gpu_support = scamp.gpu_supported()
                print(has_gpu_support)
            if data_b is None:
                mp, index = scamp.selfjoin(data, subsequence_len)
            else:
                if print_flag: print("--> data_b provided => Executing abjoin")
                mp, index = scamp.abjoin(data, data_b, subsequence_len, threads, gpus)
    if timed: 
        timer.end()
        duration = timer.duration() 
    if print_flag: 
        if timed: 
            print(f"matrix profile {duration} seconds -->")
        else: 
            print("matrix profile -->")
    return mp, index, index_left, index_right, duration

# %% ../nbs/mplots.ipynb 15
def compute(
    self : MatrixProfile, 
    data : List[float],
    subsequence_len : int, 
    data_b : List[float] = None,
    method : str = 'scamp',  
    threads : int = 1,
    gpus : List[int] = [],
    print_flag : bool = False, 
    debug : bool = False, 
    timed :bool = True
):
    if print_flag: print("Subsequence len: ", subsequence_len)
    self.subsequence_len = subsequence_len
    self.method = method
    self.matrix_profile, self.index, self.index_left, self.index_right, self.computation_time = matrix_profile(
        data, subsequence_len, data_b, method, threads, gpus, print_flag, debug, timed
    )
    return self.matrix_profile
MatrixProfile.compute = compute

# %% ../nbs/mplots.ipynb 20
@dataclass
class MatrixProfiles:
    matrix_profiles: List[MatrixProfile] =  field(default_factory=list)
    data: List[float] = field(default_factory=list)
    data_b : List[float] = None
    
    subsequence_len: int = 0

    def append(self, mp: MatrixProfile):
        self.matrix_profiles.append(deepcopy(mp))
        self.subsequence_len = mp.subsequence_len
    def compute(
        self, 
        method : str      = 'scamp',  
        threads: int      = 1,
        gpus : List[int]  = field(default_factory=list),
        print_flag : bool = False, 
        debug : bool      = False, 
        timed : bool      = True
    ):
        """ 
        Computes the Matrix Profile for data & data_b arrays using subsequence_len length.
        Appends the resulting MP to the matrix_profiles list.
        """
        mp = MatrixProfile()
        mp.compute(
            data            = self.data, 
            subsequence_len = self.subsequence_len, 
            data_b          = self.data_b,
            method          = method, 
            threads         = threads,
            gpus            = gpus,
            print_flag      = print_flag, 
            debug           = debug, 
            timed           = timed
        )
        
        mp.method = method
        self.matrix_profiles.append(mp)
        
        if print_flag: 
            print("MPs | compute -> Subsequence len outside: ", self.subsequence_len)
            print("MPs | compute -> Subsequence len inside: ", mp.subsequence_len)
            print("MPs | compute -> method outside: ", self.matrix_profiles[-1].method)
            print("MPs | compute -> method inside: ", mp.method)
        return mp
    
    def plot(self, ids = []):
        if ids == []: ids = range(len(self.matrix_profiles))
        num_plots = len(ids)+1
        fig = plt.figure(figsize=(10, 6))
        gs = GridSpec(num_plots, 1, height_ratios=[1] + [4] * (num_plots -1))
        # Serie temporal
        ax1 = fig.add_subplot(gs[0])
        ax1.plot(self.data, label="Data")
        ax1.set_title("Time Serie")
        ax1.legend()
        # MPlots
        for i in ids:
            ax2 = fig.add_subplot(gs[i+1], sharex=ax1)
            mp_values = self.matrix_profiles[i].matrix_profile.astype(float)
            ax2.imshow(mp_values.reshape(-1, 1).T, aspect='auto', origin='lower', cmap='hot', extent=(0, len(self.data), 0, self.subsequence_len))
            ax2.set_title(f"MPlot - {i} - {self.matrix_profiles[i].method}")
        plt.tight_layout()
        plt.show()

    def get_ordered_idx(self, id, pos):
        mp_sorted = np.argsort( self.matrix_profiles[id].matrix_profile )
        return mp_sorted[pos]
        
    def get_motif_idx(self, id): 
        motif_idx = self.get_ordered_idx(id, 0)
        self.matrix_profiles[id].motif_idx = motif_idx
        self.matrix_profiles[id].motif_nearest_neighbor_idx = self.matrix_profiles[id].index[motif_idx]
        
        if ( self.matrix_profiles[id].method == 'stump' ):
            self.matrix_profiles[id].motif_nearest_neighbor_idx_left = self.matrix_profiles[id].index_left[motif_idx]
            self.matrix_profiles[id].motif_nearest_neighbor_idx_right = self.matrix_profiles[id].index_right[motif_idx]
        return self.matrix_profiles[id].motif_idx, self.matrix_profiles[id].motif_nearest_neighbor_idx, self.matrix_profiles[id].motif_nearest_neighbor_idx_left, self.matrix_profiles[id].motif_nearest_neighbor_idx_right
    
    def get_anomaly_idx(self, id): 
        discord_idx = self.get_ordered_idx(id, -1)
        self.matrix_profiles[id].discord_idx = discord_idx
        self.matrix_profiles[id].discord_nearest_neighbor_idx = self.matrix_profiles[id].index[discord_idx]
        
        if ( self.matrix_profiles[id].method == 'stump' ):
            self.matrix_profiles[id].discord_nearest_neighbor_idx_left = self.matrix_profiles[id].index_left[discord_idx]
            self.matrix_profiles[id].discord_nearest_neighbor_idx_right = self.matrix_profiles[id].index_right[discord_idx]
            
        return self.matrix_profiles[id].discord_idx, self.matrix_profiles[id].discord_nearest_neighbor_idx, self.matrix_profiles[id].discord_nearest_neighbor_idx_left, self.matrix_profiles[id].discord_nearest_neighbor_idx_right
    
    
    def plot_motif(
        self, 
        ts_name,
        id, 
        idx, 
        nearest_neighbor_idx, 
        title_fontsize = '30', 
        other_fontsize = '20'
    ): 
        fig, axs = plt.subplots(2, sharex=True, gridspec_kw={'hspace': 0.4})
        plt.suptitle('Motif (Pattern) Discovery | ' + self.matrix_profiles[id].method , fontsize=title_fontsize)

        axs[0].plot(self.data.values)
        axs[0].set_ylabel(ts_name, fontsize=other_fontsize)
        rect = Rectangle((idx, 0), self.subsequence_len, 40, facecolor='lightgrey')
        axs[0].add_patch(rect)
        rect = Rectangle((nearest_neighbor_idx, 0), self.subsequence_len, 40, facecolor='lightgrey')
        axs[0].add_patch(rect)
        axs[1].set_xlabel('Index', fontsize =other_fontsize)
        axs[1].set_ylabel('Matrix Profile', fontsize=other_fontsize)
        axs[1].axvline(x=idx, linestyle="dashed", color = "black")
        axs[1].axvline(x=nearest_neighbor_idx, linestyle="dashed", color="red")
        axs[1].plot(self.matrix_profiles[id].matrix_profile)
        plt.show()
        
        


# %% ../nbs/mplots.ipynb 31
def plot_dataFrame(title, df, vars = [], interval = 10000):
    if len(vars) > 0:
        num_vars = len(df.columns)
    
        for var_num in vars:
            if var_num >= len(df.columns):
                raise ValueError("var_num "+var[var_num] + "is out of the range of DataFrame columns: " + num_vars)

        num_vars = len(vars)
        
        ### Start the plot 

        #fig = plt.figure(figsize=(10, num_intervals * 3))  # Ajusta el tamaño del plot según el número de intervalos
        
        num_intervals = df.shape[0] // interval + 1
        fig = plt.figure(figsize=(10, num_vars * num_intervals * 3))  ## Size
        gs = GridSpec(num_intervals*num_vars, 1) # 1 column, len(vars) rows
        var_pos = 0
        for var_num  in vars:
            var_name = df.columns[var_num]
            data = df[var_name]
            for i in range(num_intervals):    
                start_idx = i * interval
                end_idx = len(data) if i == (num_intervals - 1) else start_idx + interval
                ax = fig.add_subplot(gs[var_pos+i])
                ax.plot(np.arange(start_idx, end_idx), data[start_idx:end_idx], label=f"{var_name} [{start_idx}, {end_idx}]")
                ax.set_title(f"{var_name} [{start_idx}, {end_idx}]")
                ax.set_xlabel("Time")
                ax.set_ylabel(var_name)
                ax.legend()
            var_pos += 1
                
        plt.suptitle(title, fontsize=16)
        plt.tight_layout()
        plt.show()
    else: raise ValueError("No variable proposed for plotting")

# %% ../nbs/mplots.ipynb 32
def plot_dataFrame_compareSubsequences(
    title, df, var, subsequence_len, seq1_init, seq2_init, 
    title_fontsize = '30',
    others_fontsize='20'
):
    fig, axs = plt.subplots(2)
    fig.subplots_adjust(hspace=0.4) 
    plt.suptitle(title, fontsize=title_fontsize)
    var_name = df.columns[var]
    axs[0].set_ylabel(var_name, fontsize=others_fontsize)
    axs[0].plot(df[var_name], alpha=0.5, linewidth=1)
    axs[0].plot(df[var_name].iloc[seq1_init:seq1_init+subsequence_len])
    axs[0].plot(df[var_name].iloc[seq2_init:seq2_init+subsequence_len])
    rect = Rectangle((seq1_init, 0), subsequence_len, 40, facecolor='lightgrey')
    axs[0].add_patch(rect)
    axs[0].set_xlabel("Index", fontsize=others_fontsize)

    rect = Rectangle((seq2_init, 0), subsequence_len, 40, facecolor='lightgrey')
    axs[0].add_patch(rect)
    axs[1].set_xlabel("Relative Index (subsequence)", fontsize=others_fontsize)
    axs[1].set_ylabel(var_name, fontsize=others_fontsize)
    axs[1].plot(df[var_name].values[seq1_init:seq1_init+subsequence_len], color='C1')
    axs[1].plot(df[var_name].values[seq2_init:seq2_init+subsequence_len], color='C2')
    plt.show()
    

# %% ../nbs/mplots.ipynb 34
def df_plot_colored_variables(df):
    # Show time series plot
    fig, ax = plt.subplots(1, figsize=(15,5), )
    cmap = matplotlib.colormaps.get_cmap('viridis')
    #df.plot(color=cmap(0.05), ax=ax) # or use colormap=cmap
    df.plot(colormap=cmap, ax=ax) # or use colormap=cmap
    # rect = Rectangle((5000, -4.2), 3000, 8.4, facecolor='lightgrey', alpha=0.5)
    # ax.add_patch(rect)
    plt.tight_layout()
    plt.legend()
    display(plt.show())

# %% ../nbs/mplots.ipynb 35
def plot_df_with_intervals_and_colors(title, df, interval=10000):
    num_variables = len(df.columns)
    num_intervals = len(df) // interval + 1  # Calcula el número necesario de intervalos/subplots

    fig = plt.figure(figsize=(10, num_intervals * 3 * num_variables))  # Ajusta el tamaño del plot
    gs = GridSpec(num_intervals * num_variables, 1)
    
    cmap = matplotlib.colormaps.get_cmap('viridis')

    for var_num, var in enumerate(df.columns):
        data = df[var]
        for i in range(num_intervals):
            ax = fig.add_subplot(gs[var_num * num_intervals + i])
            start_idx = i * interval
            end_idx = start_idx + interval

            if i == num_intervals - 1:  # Ajusta el último intervalo para incluir todos los datos restantes
                end_idx = len(data)

            color = cmap(var_num / num_variables)  # Asigna un color basado en la variable
            ax.plot(np.arange(start_idx, end_idx), data[start_idx:end_idx], label=f"{var} [{start_idx}, {end_idx}]", color=color)
            ax.set_title(f"{var} [{start_idx}, {end_idx}]")
            ax.set_xlabel("Index")
            ax.set_ylabel(var)
            ax.legend()

    plt.suptitle(title, fontsize=16)
    plt.tight_layout()
    plt.show()

# %% ../nbs/mplots.ipynb 36
def plot_motif(df, motif_idx, nearest_neighbor_idx, variable_name, title, padding = 1000, m = 1, mp = None):
    fig, axs = plt.subplots(2, sharex = True, gridspec_kw={'hspace': 0})
    plt.suptitle('Motif (Pattern) Discovery', fontsize='30')
    padding = min(padding, len(df[variable_name].values) // 2)

    # Calcula los límites para hacer zoom
    x_min = max(min(motif_idx, nearest_neighbor_idx) - padding, 0)
    x_max = min(max(motif_idx, nearest_neighbor_idx) + padding, len(df[variable_name].values))

    axs[0].plot(df[variable_name].values)
    axs[0].set_xlim([x_min, x_max])  # Aplica el zoom aquí
    axs[0].set_ylabel(title, fontsize='20')
        
    axs[0].set_ylabel(title, fontsize='20')
    rect = Rectangle((motif_idx, 0), m, 40, facecolor='lightgrey')
    axs[0].add_patch(rect)
    rect = Rectangle((nearest_neighbor_idx, 0), m, 40, facecolor='lightgrey')
    axs[0].add_patch(rect)
    axs[1].set_xlabel('Time', fontsize ='20')
    axs[1].set_ylabel('Matrix Profile', fontsize='20')
    axs[1].axvline(x=motif_idx, linestyle="dashed")
    axs[1].axvline(x=nearest_neighbor_idx, linestyle="dashed")
    axs[1].plot(mp)
    plt.show()

# %% ../nbs/mplots.ipynb 37
def plot_motif_separated(df, motif_idx=0, nearest_neighbor_idx=0, variable_name="", title="", padding=1000, m=1, mp=None):
    fig, axs = plt.subplots(4, sharex=False, figsize=( 12, 5), gridspec_kw={'hspace': 0.5})
    plt.suptitle('Motif (Pattern) Discovery', fontsize='20')
    
    padding = max(m, min(padding, len(df[variable_name].values) // 2))

    x_min_motif = max(motif_idx - padding, 0)
    x_max_motif = min(motif_idx + padding, len(df[variable_name].values))

    axs[0].plot(df[variable_name].values)
    axs[0].set_xlim([x_min_motif, x_max_motif])
    axs[0].set_ylabel(title, fontsize='10')
    rect_motif = Rectangle((motif_idx, df[variable_name].min()), m, df[variable_name].max() - df[variable_name].min(), facecolor='lightgrey')
    axs[0].add_patch(rect_motif)

    axs[1].plot(mp)
    axs[1].set_xlim([x_min_motif, x_max_motif])
    axs[1].set_xlabel('Time', fontsize='10')
    axs[1].set_ylabel('MP - Min', fontsize='10')
    axs[1].axvline(x=motif_idx, linestyle="dashed")

    x_min_neighbor = max(nearest_neighbor_idx - padding, 0)
    x_max_neighbor = min(nearest_neighbor_idx + padding, len(df[variable_name].values))

    axs[2].plot(df[variable_name].values)
    axs[2].set_xlim([x_min_neighbor, x_max_neighbor])
    axs[2].set_ylabel(title, fontsize='10')
    rect_neighbor = Rectangle((nearest_neighbor_idx, df[variable_name].min()), m, df[variable_name].max() - df[variable_name].min(), facecolor='lightgrey')
    axs[2].add_patch(rect_neighbor)

    axs[3].plot(mp)
    axs[3].set_xlim([x_min_neighbor, x_max_neighbor])
    axs[3].set_xlabel('Time', fontsize='10')
    axs[3].set_ylabel('MP-max', fontsize='10')
    axs[3].axvline(x=nearest_neighbor_idx, linestyle="dashed")

    plt.show()

# %% ../nbs/mplots.ipynb 39
class GD_Mat:
    def __init__(self, id,  name, data_path = '~/data'):
        self.id                 = id #GD id
        self.data_path          = os.path.expanduser(data_path) # Local data path
        self.zip_path           = os.path.join(self.data_path, name + '.zip')
        self.mat_path           = os.path.join(self.data_path, name + '.mat')
        self.mats_files         = None
        self.mats               = None #Downloaded matlab matrices
        self.mats_df            = None
        self.num_mats           = 0
        self.num_mats_extracted = 0
        
    def download_file_from_google_drive(self):
        return load.download_file_from_google_drive(self.id, self.zip_path)
        
    def get_mat_files(self):
        self.mats_files = [f for f in load.zip_contents(self.zip_path) if not f.startswith('__MACOSX/')]
        self.num_mats = len(self.mats_files)
        self.mats = self.mats_df = [None]*self.num_mats
    
    def unzip_mat(self, all_one, case = '', print_flag = False): 
        str = load.unzip_mat(all_one, self.zip_path, self.data_path, case, print_flag)
        self.get_mat_files()
        return str
        
    def mat2csv(self, case_id, print_flag = False):
        if print_flag: print("--> mat2csv", case_id)
        case = self.mats_files[case_id]
        case_path = os.path.join(self.data_path, case)
        print("Mat2csv case", case_path)
        self.mats_df[case_id] = load.mat2csv(case_path, self.data_path, print_flag)
        if print_flag: print("mat2csv", case_id, "-->")
        
    def __str__(self): 
        str = f"FileID: {self.id}\nData path: {self.data_path}\n"
        str += f"zip path: {self.zip_path}\nmat_files: {self.mats_files}"
        str +=f"\nnum_mats: {self.num_mats}"
        return str
    

# %% ../nbs/mplots.ipynb 42
@dataclass
class MatlabMatrix: 
    #File name
    filename : str = ""
    #Matrix name
    matname : str = ""
    #1-D numpy array with the time serie data
    data : List [ float ] = None
    #Length used for smoothing the time serie (if smoothed)
    smoothing_window_len : int = None
    #Wether if it has been smoothed yet or not 
    smoothed : bool = False
    path : str = None
    
    def load(
        self, 
        #Col in the matrix containing the time serie
        numcol : int, 
        #Wether to print messages for debugging or not
        print_flag : bool = False,
        force_smooth : bool = False,
        path = "."
    ) -> List [ float ] : 
        """ Reads the file and load the column numcol of the matrix as time series data. """
        
        if self.path is None:
            path = path

        dir = self.path + '/' + self.filename  + ".mat"
        
        dict = octave.load(dir)
        data = dict[self.matname]
        
        if print_flag: print(data.dtype)
        
        self.data = np.array(data[:,numcol])
        
        return self.data

    def smooth(
        self, 
        window_len=11, 
        print_flag = False,
        force_smooth = False
    ) -> List [ float ]:
        """ Applies moving average for smoothing the time serie data. """
        # window_len: smoothing window size needs, which must be odd number,
        
        if ( ( not self.smoothed ) or force_smooth ) :
            self.smoothed = True
        
            # Step 1: Apply the moving average to the main part of the data using convolution
        
            self.smoothing_window_len = window_len
        
            if self.smoothing_window_len % 2 == 0:
                warnings.warn("Window len must be odd! Adding 1 to your length.")
                self.smoothing_window_len += 1
            
            if print_flag: print("---> About to get out0")
            
            out0 = np.convolve(
                self.data, 
                np.ones(self.smoothing_window_len, dtype=int),
                'valid'
            ) / self.smoothing_window_len
        
            # Step 2: Handle the beginning of the array (start)
            # Use cumulative sum and then average it by the increasing window size
        
            if print_flag : 
                print("out0 ~", out0.shape)
                print("---> About to get start")
        
            r = np.arange(1, self.smoothing_window_len-1, 2)
        
            if print_flag: print("r", r)
        
            start = np.cumsum(self.data[:self.smoothing_window_len-1])[::2] / r
        
            if print_flag:
                print("start", start)
                print("---> About to get stop")
        
            # Step 3: Handle the end of the array (stop)
            # Reverse the array, use cumulative sum, and then average it by the increasing window size
        
            stop = (np.cumsum(self.data[:-self.smoothing_window_len:-1])[::2] / r)[::-1]
    
            if print_flag: 
                print("stop", stop)
        
            # Step 4: Combine the start, middle, and end parts together
            self.data = np.concatenate((start, out0, stop))
            return self.data

# %% ../nbs/mplots.ipynb 46
def moving_mean(a, w):
  result = np.zeros((len(a) - w + 1,))
  p = a[0]
  s = 0
  for i in range(1, w):
    x = p + a[i]
    z = x - p
    s += (p - (x - z)) + (a[i] - z)
    p = x
  
  result[0] = (p + s) / w

  for i in range(w, len(a)):
    x = p - a[i - w]
    z = x - p
    s += (p - (x - z)) - (a[i - w] + z)
    p = x

    x = p + a[i]
    z = x - p
    s += (p - (x - z)) + (a[i] - z)
    p = x
    result[i - w + 1] = (p + s) / w

  return result;
def sum_of_squared_differences(a, means, w):
  result = np.zeros((len(a) - w + 1,))
  for i in range(len(a) - w + 1):
    vals = a[i:i+w] - means[i]
    vals = vals * vals
    result[i] = np.sum(vals)
  return result
def get_precomputes(T, m, nanvalues):
  flatness_epsilon = 1e-13
  n = len(T) - m + 1;
  df = np.zeros((n,))
  dg = np.zeros((n,))

  means = moving_mean(T,m)

  norms = sum_of_squared_differences(T, means, m)

  for i in range(n):
    if nanvalues[i]:
      norms[i] = np.nan
    elif norms[i] <= flatness_epsilon:
      norms[i] = np.nan
    else:
      norms[i] = 1.0 / math.sqrt(norms[i])

  for i in range(n-1):
    df[i] = (T[i + m] - T[i]) / 2.0;
    dg[i] = (T[i + m] - means[i + 1]) + (T[i] - means[i]);

  return means, norms, df, dg
def convert_non_finite_to_zero(T, m):
  timeseries_clean = np.zeros((len(T),))
  nanvals = np.zeros((len(T) - m + 1,))
  steps_since_last_nan = m
  for i in range(len(T)):
    if np.isfinite(T[i]):
      timeseries_clean[i] = T[i]
    else:
      steps_since_last_nan = 0
      timeseries_clean[i] = 0
    if i >= m - 1:
      nanvals[i - m + 1] = steps_since_last_nan < m
    steps_since_last_nan += 1
  return timeseries_clean, nanvals
# Computes the distance matrix using the diagonal update method used in SCAMP
def distance_matrix(a,b,w):
    has_b = True
    if b is None:
        has_b = False
        b = a
    na = len(a) - w + 1
    if not has_b:
        nb = na
    else:
        nb = len(b) - w + 1
    out = np.ones((nb,na)) * -2


    a, nan_a = convert_non_finite_to_zero(a,w)
  
    if has_b:
      b, nan_b = convert_non_finite_to_zero(b,w)
    else:
      b = a;

    mua, siga, dfa, dga = get_precomputes(a,w,nan_a)
    if not has_b:
        mub = mua
        sigb = siga
        dfb = dfa
        dgb = dga
    else:
        mub, sigb, dfb, dgb = get_precomputes(b,w, nan_b)

    diagmax = na
    if not has_b:
        minlag = w // 4
    else:
        minlag = 0

    
    c = np.zeros((diagmax - minlag,)) 
    for diag in range(minlag,diagmax):
      c[diag-minlag] = np.sum((a[diag:diag+w]-mua[diag]) * (b[:w]-mub[0]))
    
    for offset in range(nb-minlag):
      result = c*(sigb[offset]*siga[minlag+offset:])
      out[offset, minlag+offset:] = result
      if not has_b:
        out[minlag+offset:, offset] = result
      x = c + dfb[offset] * dga[minlag+offset:] + dfa[minlag+offset:]*dgb[offset]
      c = x[:-1]
    if has_b:
      diagmax = nb
      c = np.zeros((diagmax - minlag,)) 
      for diag in range(minlag,diagmax):
        c[diag-minlag] = np.sum((b[diag:diag+w]-mub[diag]) * (a[:w]-mua[0]))
      for offset in range(na-minlag):
        result = c*(siga[offset]*sigb[minlag+offset:])
        out[minlag+offset:, offset] = result
        x = c + dfa[offset] * dgb[minlag+offset:] + dfb[minlag+offset:]*dga[offset]
        c = x[:-1]

    out[np.isnan(out)] = -2;
    return out

# %% ../nbs/mplots.ipynb 47
def make_symmetric_(mat : np.array(float)) -> None:
    """ Ensures down-left triangle equals to up-right triangle """
    for i in range(len(mat)):
       mat[i:,i] = mat[i,i:]
def check_symmetric(mat : np.array(float)) -> bool:
    """ Check wether if down-left triangle equals to up-right triangle """
    sym = True
    i = 0
    while (i < len(mat) and sym):
        sym = np.array_equal(mat[i:,i], mat[i,i:])
        i+=1
    return sym


# %% ../nbs/mplots.ipynb 49
@dataclass
class DistanceProfile: 
    """ Similarity matrix """
    # -- Similarity Matrix / Distance Profile
    similarity_matrix: List[ List [ float ] ] = field(default_factory=list)
    # -- Time series A (Query Time Serie
    data: List [ float ]  = None
    # -- Reference sequence
    data_b : List [ float ]  = None
    # -- 
    subsequence_len : int = 1

    def load_data_from_matlab(
        self, 
        matrix : MatlabMatrix = None,
        filename : str = None,
        matname : str = None,
        smoothing_window_len : int = None,
        path : str = ".",
        numcol : int  = 0,
        force_smooth : bool = False,
        set_a_or_b : bool = True,
        print_flag : bool = False
    ) ->  List [ float ] :
        if matrix is None:
            matrix = MatlabMatrix(
                filename = filename, 
                matname = matname,
                smoothing_window_len = smooting_window_len,
                path = path
            )
        matrix_data = matrix.load(
            numcol, print_flag, force_smooth, path
        )

        if (set_a_or_b):   
            if print_flag: print("Copy A")
            self.data = deepcopy(matrix_data)
        else: 
            if print_flag: print("Copy B")
            self.data_b = deepcopy(matrix_data)

        return matrix_data
        

    
    def compute(
        self,
        method                      = 'scamp',
        print_flag : bool           = False,
        debug : bool                = False,
        timed : bool                = True, 
        allow_experimental : bool   = True, 
        ensure_symetric : bool      = True,
        #--- Scamp
        mheight : int               = None,
        mwidth : int                = None,
        #--- Octave functions expected parameters ---
        min_lag : int               = 0, #May be needed if SimMat is used
        #--- may be needed by runsplat, splat & piecewiseSplat
        multiresolution : int       = 0,
        calibration : int           = 0,
        patch_size                  = 5000 #Size of patches to compute (the final matrix, similar to mheight, mwidht)
    ) -> List [ List [ float ] ] :
        
        complete                    = self.data_b == None
        n                           = len(self.data)
        rows                        = n - self.subsequence_len + 1
        if (complete): 
            columns = rows
            reference_seq = self.data
        else: 
            reference_seq = data_b
            columns = len(reference_seq) + 1
        self.similarity_matrix = np.empty((rows, columns))
        if timed: 
            timer = ut.Time()
            timer.start()
        match method:
            case 'stump':
                if print_flag: print("--> Stump")
                for i in range(rows):
                    self.similarity_matrix[i,:] =  stump.core.mass(
                        self.data[i:i + self.subsequence_len], reference_seq
                    )
                        
            case 'scamp': 
                if print_flag: print("--> Scamp")
                if complete and allow_experimental:
                    if print_flag: 
                        print("--> selfjoin_matrix", self.similarity_matrix.shape)

                        if mheight is None: 
                            mheight = n - self.subsequence_len + 1
                        if mwidth is None:
                            mwidth =  n - self.subsequence_len + 1
                        self.similarity_matrix = scamp.selfjoin_matrix(
                            self.data, 
                            self.subsequence_len,
                            gpus    = [],
                            mheight = mheight,
                            mwidth  = mwidth,
                            verbose = print_flag,
                            pearson = True
                        )
                    if print_flag: print("selfjoin_matrix -->", self.similarity_matrix.shape)
                else:
                    self.similarity_matrix = distance_matrix(
                            self.data, #a_data
                            reference_seq,  #b_data
                            self.subsequence_len #windos
                        )
            case 'octave-mpx':
                self.similarity_matrix = octave.SimMat(
                    self.data,
                    self.subsequence_len,
                    self.data_b,
                    min_lag,
                    nout=1
                )
            case 'octave-runsplat':
                self.similarity_matrix = octave.runsplat(
                    self.subsequence_len,
                    self.data, 
                    self.data_b,
                    multiresolution, 
                    calibration, 
                    display_mplot,
                    piecewise, 
                    patch_size
                )
            case 'octave-splat':
                print("multiresolution before octave call", multiresolution)
                args = {
                    'timeSeriesA': self.data, 
                    'subseqLen': self.subsequence_len,
                    'timeSeriesB': self.data_b, 
                    #displat_mplot setted up to false as default because I couldn't get the plot shown in Jupyter Notebook... waiting for python implementation. (Zack!)
                    'plotting': False,
                    'multiresolution': multiresolution,
                    'calibration': calibration
                };
                self.similarity_matrix = octave.SPLAT(
                    self.data, self.subsequence_len, 
                    self.data_b, False, 
                    multiresolution, calibration
                )
            case 'octave-piecewiseSplat':
                self.similarity_matrix = octave.piecewiseSplat(
                    self.data,
                    self.subsequence_len, 
                    patch_size,
                    False, 
                    self.data_b
                )
            case _: #default scamp
                if print_flag: print("--> Invalid method. Using scamp [default]")
                self.similarity_matrix = distance_matrix(
                    self.data, #a_data
                    reference_seq,  #b_data
                    self.subsequence_len #windos
                )
                #if print_flag: print("--> Scamp")
                #self.similarity_matrix, _ = scamp.selfjoin(self.data, self.subsequence_len)
        if timed: 
            timer.end()
            duration = timer.duration() 
        if print_flag: 
            if timed: 
                print(f"matrix profile {duration} seconds -->")
            else: 
                print("matrix profile -->")
        #TODO: En mplot_explorer se asegura de que la matriz sea simétrica respecto a la diagonal
        # y tiene sentido, cuando es cuadrada, pero.... siendo así... 
        # ¿Por qué la guardo entera? Ya he guardado antes matrices simétricas como triangulares...
        # -> Pensar en cómo afectaría. Tiene sentido para el caso en que rows = columns.
        if (ensure_symetric and rows == columns) : 
            make_symmetric_(self.similarity_matrix)
        return self.similarity_matrix    
    

# %% ../nbs/mplots.ipynb 58
@dataclass
class MatrixProfilePlot:
    """ Time series similarity matrix plot """
    
    similarity_matrix : DistanceProfile = None
    
    def compute_similarity_matrix(
        self,
        method = 'scamp',
        print_flag : bool = False,
        debug : bool = False, 
        timed : bool = True, 
        allow_experimental : bool = True,
        ensure_symetric : bool = True
    ) -> List [ List [ float ] ] :
        self.similarity_matrix.compute(
            method = method,
            print_flag = print_flag,
            debug = debug,
            timed = timed, 
            allow_experimental = allow_experimental,
            ensure_symetric = ensure_symetric
        )
            
            
    def plot(self, ts_name, method = 'Scamp'):
        fig = plt.figure(figsize=(10, 10))
        gs = GridSpec(2, 1, height_ratios=[1, 4])

        # Matrix Profile
        ax1 = fig.add_subplot(gs[0])
        ax1.plot(self.similarity_matrix.data, label="Time Serie")
        ax1.set_title(ts_name + " | " +  method)
        ax1.legend()

        # MPlot (Distance Profile)
        ax2 = fig.add_subplot(gs[1], sharex=ax1)
        # Utilizar 'imshow' para visualizar la matriz MPlot
        ax2.imshow(self.similarity_matrix.similarity_matrix, 
                   aspect='auto', origin='lower', cmap='hot', 
                   extent=(0, len(self.similarity_matrix.data) - self.similarity_matrix.subsequence_len, 
                           0, len(self.similarity_matrix.data) - self.similarity_matrix.subsequence_len)
                  )
        ax2.set_title("MPlot")
        ax2.set_xlabel('TA')
        ax2.set_ylabel('TB')

        plt.tight_layout()
        plt.show()

# %% ../nbs/mplots.ipynb 64
@dataclass
class MatrixProfilePlotCached:
    """ Time series similarity matrix plot using cache """
    
    similarity_matrix : DistanceProfile = None
    
    def compute_similarity_matrix(
        self,
        method = 'scamp',
        print_flag : bool = False,
        debug : bool = False, 
        timed : bool = True, 
        allow_experimental : bool = True,
        ensure_symetric : bool = True
    ) -> List [ List [ float ] ] :
        self.similarity_matrix.compute(
            method = method,
            print_flag = print_flag,
            debug = debug,
            timed = timed, 
            allow_experimental = allow_experimental,
            ensure_symetric = ensure_symetric
        )
            
            
    def plot(self, ts_name, method = 'Scamp'):
        fig = plt.figure(figsize=(10, 10))
        gs = GridSpec(2, 1, height_ratios=[1, 4])

        # Serie temporal
        ax1 = fig.add_subplot(gs[0])
        ax1.plot(self.similarity_matrix.data, label="Time Serie")
        ax1.set_title(ts_name + " | " +  method)
        ax1.legend()

        # MPlot
        ax2 = fig.add_subplot(gs[1], sharex=ax1)
        # Utilizar 'imshow' para visualizar la matriz MPlot
        ax2.imshow(self.similarity_matrix.similarity_matrix, 
                   aspect='auto', origin='lower', cmap='hot', 
                   extent=(0, len(self.similarity_matrix.data) - self.similarity_matrix.subsequence_len, 
                           0, len(self.similarity_matrix.data) - self.similarity_matrix.subsequence_len)
                  )
        ax2.set_title("MPlot")
        ax2.set_xlabel('TA')
        ax2.set_ylabel('TB')

        plt.tight_layout()
        plt.show()

# %% ../nbs/mplots.ipynb 66
eamonn_drive_mplots = {
    'insects0': {
        'id': '1qq1z2mVRd7PzDqX0TDAwY7BcWVjnXUfQ',
        'name': 'InsectData-fig11'
    }
}
